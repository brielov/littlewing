#!/usr/bin/env bun
// @bun
import {
  build,
  processLoadedConfigs,
  resolveBuildOptions
} from "../shared/bunup-0rejsmya.js";
import {
  BunupBuildError,
  BunupCLIError,
  BunupWatchError,
  __require,
  __toESM,
  ensureArray,
  formatFileSize,
  getShortFilePath,
  handleError,
  handleErrorAndExit,
  isJavascriptFile,
  isTypeScriptFile,
  logTime,
  logger,
  parseErrorMessage
} from "../shared/bunup-qb65sm3k.js";

// packages/bunup/src/cli/index.ts
import { loadConfig } from "coffi";
import pc4 from "picocolors";
// packages/bunup/package.json
var version = "0.15.13";

// packages/bunup/src/printer/print-build-report.ts
import { promisify } from "util";
import { brotliCompress } from "zlib";
import pc from "picocolors";
var brotliAsync = promisify(brotliCompress);
async function printBuildReport(buildResult) {
  const options = buildResult.build.options;
  const {
    gzip = !options.compile,
    brotli = false,
    maxBundleSize
  } = options.report ?? {};
  if (options.compile && (brotli || gzip)) {
    throw new BunupBuildError("Brotli or Gzip size report is not available when the compile option is enabled.");
  }
  const showCompression = gzip || brotli;
  const files = await Promise.all(buildResult.files.map(async (file) => {
    const pathRelative = file.pathRelativeToOutdir;
    const size = file.size;
    const isDts = file.dts && file.kind === "entry-point";
    const isJs = isTypeScriptFile(file.fullPath) || isJavascriptFile(file.fullPath);
    const isExecutable = file.kind === "executable";
    let gzipSize;
    let brotliSize;
    if (showCompression) {
      const bunFile = Bun.file(file.fullPath);
      const uint8 = new Uint8Array(await bunFile.arrayBuffer());
      const [gzipResult, brotliResult] = await Promise.all([
        gzip ? Promise.resolve(Bun.gzipSync(uint8)) : Promise.resolve(null),
        brotli ? brotliAsync(uint8) : Promise.resolve(null)
      ]);
      gzipSize = gzipResult?.length;
      brotliSize = brotliResult?.length;
    }
    return {
      path: pathRelative,
      fullPath: `${options.outDir}/${pathRelative}`,
      size,
      gzipSize,
      brotliSize,
      format: file.format,
      isDts,
      isJs,
      isExecutable
    };
  }));
  const totalSize = files.reduce((sum, file) => sum + file.size, 0);
  const totalGzipSize = files.reduce((sum, file) => sum + (file.gzipSize || 0), 0);
  const totalBrotliSize = files.reduce((sum, file) => sum + (file.brotliSize || 0), 0);
  const hasExecutable = files.some((f) => f.isExecutable);
  const labels = [
    ...ensureArray(options.format),
    ...hasExecutable ? ["executable"] : []
  ];
  const showLabel = labels.length > 1 || labels[0] === "cjs" || hasExecutable;
  const labelWidth = showLabel ? Math.max(...labels.map((f) => `[${f}] `.length)) : 0;
  const pathWidth = Math.max(...files.map((f) => f.fullPath.length), "Output".length);
  const sizeWidth = Math.max(formatFileSize(totalSize).length, "Raw".length);
  const gzipWidth = gzip ? Math.max(formatFileSize(totalGzipSize).length, "Gzip".length) : 0;
  const brotliWidth = brotli ? Math.max(formatFileSize(totalBrotliSize).length, "Brotli".length) : 0;
  const pad = (str, width, align = "left") => {
    const diff = width - str.length;
    return align === "left" ? str + " ".repeat(Math.max(0, diff)) : " ".repeat(Math.max(0, diff)) + str;
  };
  console.log("");
  if (options.name) {
    console.log("");
    console.log(`  ${pc.bgBlueBright(` ${options.name} `)}`);
  }
  console.log("");
  const headers = [
    pad("  Output", pathWidth + labelWidth + 2),
    pad("Raw", sizeWidth, "right")
  ];
  if (gzip)
    headers.push(pad("Gzip", gzipWidth, "right"));
  if (brotli)
    headers.push(pad("Brotli", brotliWidth, "right"));
  console.log(pc.dim(headers.join("    ")));
  console.log("");
  for (const file of files) {
    let label = "";
    if (showLabel) {
      let plainLabel = "";
      if (file.isJs) {
        plainLabel = `[${file.format}] `;
      }
      if (file.isExecutable) {
        plainLabel = `[executable] `;
      }
      label = pc.dim(pad(plainLabel, labelWidth));
    }
    const outDirWithSlash = `${options.outDir}/`;
    const fileName = file.isDts ? pc.green(pc.bold(file.path)) : file.path;
    const styledPath = `${pc.dim(outDirWithSlash)}${fileName}`;
    const plainPath = `${outDirWithSlash}${file.path}`;
    const filePathColumn = `  ${label}${styledPath}${" ".repeat(Math.max(0, pathWidth - plainPath.length))}`;
    const fileRow = [
      filePathColumn,
      pad(formatFileSize(file.size), sizeWidth, "right")
    ];
    if (gzip) {
      const gzipStr = file.gzipSize ? formatFileSize(file.gzipSize) : pc.dim("-");
      fileRow.push(pad(gzipStr, gzipWidth, "right"));
    }
    if (brotli) {
      const brotliStr = file.brotliSize ? formatFileSize(file.brotliSize) : pc.dim("-");
      fileRow.push(pad(brotliStr, brotliWidth, "right"));
    }
    console.log(fileRow.join("    "));
  }
  console.log("");
  const summaryRow = [
    `  ${pc.bold(pad(`${files.length} ${files.length === 1 ? "file" : "files"}`, pathWidth + labelWidth))}`,
    pc.bold(pad(formatFileSize(totalSize), sizeWidth, "right"))
  ];
  if (gzip && totalGzipSize > 0) {
    summaryRow.push(pc.bold(pad(formatFileSize(totalGzipSize), gzipWidth, "right")));
  } else if (gzip) {
    summaryRow.push(pad("", gzipWidth));
  }
  if (brotli && totalBrotliSize > 0) {
    summaryRow.push(pc.bold(pad(formatFileSize(totalBrotliSize), brotliWidth, "right")));
  } else if (brotli) {
    summaryRow.push(pad("", brotliWidth));
  }
  console.log(summaryRow.join("    "));
  if (maxBundleSize && totalSize > maxBundleSize) {
    console.log("");
    console.warn(pc.yellow(`  Bundle size ${pc.bold(formatFileSize(totalSize))} exceeds limit ${pc.bold(formatFileSize(maxBundleSize))}`));
  }
  console.log("");
}

// packages/bunup/src/watch.ts
import path from "path";
import pc2 from "picocolors";
async function watch(userOptions, rootDir, configFilePath) {
  const watchPaths = new Set;
  const options = resolveBuildOptions(userOptions);
  const uniqueEntries = new Set(ensureArray(options.entry));
  for (const entry of uniqueEntries) {
    const entryPath = path.resolve(rootDir, entry);
    const parentDir = path.dirname(entryPath);
    watchPaths.add(parentDir);
  }
  if (configFilePath) {
    watchPaths.add(configFilePath);
  }
  const chokidar = await import("chokidar");
  const watcher = chokidar.watch(Array.from(watchPaths), {
    ignoreInitial: true,
    ignorePermissionErrors: true,
    ignored: [
      /[\\/]\.git[\\/]/,
      /[\\/]node_modules[\\/]/,
      path.resolve(rootDir, options.outDir)
    ]
  });
  let isRebuilding = false;
  let buildCount = 0;
  let lastChangedFile;
  const triggerRebuild = async (initial, changed) => {
    if (isRebuilding) {
      return;
    }
    isRebuilding = true;
    try {
      console.clear();
      await new Promise((resolve) => setTimeout(resolve, 20));
      if (lastChangedFile === changed) {
        buildCount++;
      } else {
        buildCount = 1;
      }
      lastChangedFile = changed;
      if (!initial) {
        console.log(`
  ${buildCount > 1 ? pc2.magentaBright(`[x${buildCount}] `) : ""}${pc2.green(`Changed:`)} ${changed}${options.name ? ` ${pc2.bgBlueBright(` ${options.name} `)}` : ""}`);
      }
      const start = performance.now();
      const buildResult = await build(userOptions, rootDir);
      await printBuildReport(buildResult);
      if (!initial) {
        console.log(`
  ${pc2.green("\u2713")} Rebuild completed in ${pc2.green(logTime(performance.now() - start))}`);
      }
    } catch (error) {
      handleError(error);
    } finally {
      isRebuilding = false;
    }
  };
  watcher.on("change", (changedPath) => {
    if (configFilePath && changedPath === configFilePath) {
      console.log(pc2.yellow(`
  Please restart watch mode to apply configuration changes.
`));
      cleanup();
      return;
    }
    triggerRebuild(false, getShortFilePath(changedPath));
  });
  watcher.on("error", (error) => {
    throw new BunupWatchError(`Watcher error: ${parseErrorMessage(error)}`);
  });
  const cleanup = async () => {
    await watcher.close();
    process.exit(0);
  };
  process.on("SIGINT", cleanup);
  process.on("SIGTERM", cleanup);
  await triggerRebuild(true);
}

// packages/bunup/src/cli/options.ts
import pc3 from "picocolors";
import { cli, z } from "zlye";
var program = cli().name("bunup").version(version).description("A blazing-fast build tool for your TypeScript/React libraries - built on Bun").with({
  ignoreOptionDefaultValue: true
}).example([
  pc3.gray(`${pc3.blue("bunup")}                            # Basic build`),
  pc3.gray(`${pc3.blue("bunup src/index.ts")}               # Single entry file`),
  pc3.gray(`${pc3.blue("bunup src/**/*.ts")}                             # Glob pattern for multiple files`),
  pc3.gray(`${pc3.blue("bunup --watch")}                    # Watch mode`),
  pc3.gray(`${pc3.blue("bunup --format cjs,esm")}           # Multiple formats`),
  pc3.gray(`${pc3.blue("bunup --target bun")}               # Bun target`),
  pc3.gray(`${pc3.blue("bunup src/cli.ts")}                 # Multiple entries`),
  pc3.gray(`${pc3.blue("bunup --dts.splitting")}            # Declaration splitting`),
  pc3.gray(`${pc3.blue("bunup --no-clean")}                 # Disable cleaning output directory before build`)
]).option("entry", z.union(z.string().describe("Entry file or glob pattern"), z.array(z.string()).describe("Multiple entry files or globs")).alias("e").optional()).option("config", z.union(z.string().describe("Path to a custom configuration file").alias("c").example("./configs/custom.bunup.config.js"), z.boolean().describe("Whether to use a configuration file").default(true)).optional()).option("filter", z.array(z.string()).describe("Filter workspace packages or config array items by name").optional()).option("name", z.string().describe("Name of the build configuration (for logging and identification)").example("my-library").optional()).option("out-dir", z.string().describe("Output directory for bundled files").alias("o").default("dist")).option("format", z.union(z.string().choices(["esm", "cjs", "iife"]).describe("Single output format"), z.array(z.string().choices(["esm", "cjs", "iife"])).describe("Multiple output formats")).alias("f").default("esm")).option("minify", z.boolean().describe("Enable all minification options (whitespace, identifiers, syntax)").optional()).option("minify-whitespace", z.boolean().describe("Minify whitespace in the output to reduce file size").optional()).option("minify-identifiers", z.boolean().describe("Minify identifiers by renaming variables to shorter names").optional()).option("minify-syntax", z.boolean().describe("Minify syntax by optimizing code structure").optional()).option("watch", z.boolean().describe("Watch for file changes and rebuild automatically").optional()).option("clean", z.boolean().describe("Clean the output directory before building").default(true)).option("silent", z.boolean().describe("Disable logging during the build process").alias("q").optional()).option("splitting", z.boolean().describe("Enable code splitting").default(true, "enabled by default for ESM format")).option("conditions", z.array(z.string()).describe("Package.json export conditions for import resolution").optional()).option("target", z.string().choices(["bun", "node", "browser"]).describe("Target environment for the bundle").alias("t").default("node")).option("external", z.array(z.string()).describe("External packages that should not be bundled").optional()).option("no-external", z.array(z.string()).describe("Packages that should be bundled even if listed in external").optional()).option("packages", z.string().choices(["bundle", "external"]).describe('Bundle all dependencies or externalize all dependencies. Use "bundle" to include all deps in output, or "external" to exclude all deps').optional()).option("shims", z.boolean().describe("Enable shims for Node.js globals and ESM/CJS interoperability").optional()).option("report", z.object({
  gzip: z.boolean().describe("Enable gzip compression size calculation").default(true),
  brotli: z.boolean().describe("Enable brotli compression size calculation").optional(),
  "max-bundle-size": z.number().describe("Maximum bundle size in bytes. Will warn if exceeded").optional()
}).describe("Configuration for the build report").optional()).option("dts", z.union(z.boolean().describe("Generate TypeScript declaration files (.d.ts)"), z.object({
  entry: z.union(z.string().describe("Single entrypoint for declaration file generation"), z.array(z.string()).describe("Multiple entrypoints for declaration file generation")).optional(),
  resolve: z.union(z.boolean().describe("Resolve types from dependencies"), z.array(z.string()).describe("Names or patterns of packages from which to resolve types")).optional(),
  splitting: z.boolean().describe("Enable declaration file splitting").optional(),
  minify: z.boolean().describe("Minify generated declaration files").optional(),
  "infer-types": z.boolean().describe("Use TypeScript compiler (tsc) for declarations generation (removes need for explicit type annotations)").optional(),
  tsgo: z.boolean().describe("Use TypeScript's native compiler (tsgo), 10x faster than tsc (only applicable with inferTypes enabled)").optional()
})).default(true)).option("preferred-tsconfig", z.string().describe("Path to a custom tsconfig.json file used for path resolution during both bundling and TypeScript declaration generation.").example("./tsconfig.build.json").optional()).option("sourcemap", z.union(z.boolean().describe("Generate a sourcemap (uses the inline type by default)"), z.string().choices(["none", "linked", "inline", "external"]).describe("Generate a sourcemap with a specific type")).optional()).option("define", z.object(z.string()).describe("Define global constants replaced at build time").example(`--define.PACKAGE_VERSION='"1.0.0"'`).optional()).option("env", z.union(z.string().choices(["inline", "disable"]).describe("inline: inject all, disable: inject none"), z.string().regex(/\*$/, "Environment prefix must end with *").describe("Inject env vars with this prefix").example("MYAPP_*").transform((val) => val), z.object(z.string()).describe("Explicit env var mapping").example('--env.NODE_ENV="production" --env.API_URL="https://api.example.com"')).optional()).option("banner", z.string().describe("Banner text added to the top of bundle files").optional()).option("footer", z.string().describe("Footer text added to the bottom of bundle files").optional()).option("drop", z.array(z.string()).describe("Remove function calls from bundle").example("--drop console,debugger").optional()).option("loader", z.object(z.string().choices([
  "js",
  "jsx",
  "ts",
  "tsx",
  "json",
  "toml",
  "file",
  "napi",
  "wasm",
  "text",
  "css",
  "html"
])).describe("File extension to loader mapping").example("--loader.'.css'=text --loader.'.txt'=file").optional()).option("public-path", z.string().describe("Public path prefix for assets and chunk files").example("https://cdn.example.com/").optional()).option("source-base", z.string().describe("Base directory for entry points to control output structure").example("./src").optional()).option("jsx", z.object({
  runtime: z.string().choices(["automatic", "classic"]).describe("JSX runtime mode").optional(),
  "import-source": z.string().describe("Import source for JSX functions").optional(),
  factory: z.string().describe("JSX factory function name").optional(),
  fragment: z.string().describe("JSX fragment function name").optional(),
  "side-effects": z.boolean().describe("Whether JSX functions have side effects").optional(),
  development: z.boolean().describe("Use jsx-dev runtime for development").optional()
}).describe("Configure JSX transform behavior").optional()).option("ignore-dce-annotations", z.boolean().describe("Ignore dead code elimination annotations (@__PURE__, sideEffects)")).option("emit-dce-annotations", z.boolean().describe("Force emit @__PURE__ annotations even with minification")).option("on-success", z.string().describe("Command to run after successful build").optional()).option("exports", z.union(z.boolean(), z.object({
  exclude: z.array(z.string()).describe("Entry points to exclude from exports field").optional(),
  "exclude-cli": z.boolean().describe("Whether to exclude CLI entry points (cli/bin files) from exports field").default(true),
  "exclude-css": z.boolean().describe("Whether to exclude CSS files from exports field").optional(),
  "include-package-json": z.boolean().describe('Whether to include "./package.json" in exports field').default(true),
  all: z.boolean().describe("Whether to add wildcard export for deep imports").optional()
})).describe("Configure automatic package.json exports generation").optional()).option("unused", z.union(z.boolean(), z.object({
  level: z.string().choices(["warn", "error"]).describe("The level of reporting for unused or incorrectly categorized dependencies").default("warn"),
  ignore: z.array(z.string()).describe("Dependencies to ignore when checking").optional()
})).describe("Detect unused or incorrectly categorized dependencies").optional()).option("css", z.object({
  "typed-modules": z.boolean().describe("Generate TypeScript definitions for CSS modules").default(true),
  inject: z.union(z.boolean(), z.object({
    minify: z.boolean().describe("Whether to minify the styles being injected").optional()
  })).describe("Inject CSS styles into document head at runtime").optional()
}).optional()).rest("entries", z.string().describe("Entry point files to bundle"));
var parseCliOptions = (argv) => {
  const result = program.parse(argv);
  if (!result) {
    throw new BunupCLIError("Failed to parse CLI options");
  }
  const { options, rest } = result;
  const parsedOptions = {
    ...options,
    ...rest.length > 0 ? { entry: rest } : {}
  };
  return parsedOptions;
};

// packages/bunup/src/cli/index.ts
async function main(args = Bun.argv.slice(2)) {
  const cliOptions = parseCliOptions(args);
  const cwd = process.cwd();
  let loadedConfig;
  if (cliOptions.config !== false) {
    loadedConfig = await loadConfig({
      name: "bunup.config",
      extensions: [".ts", ".js", ".mjs", ".cjs"],
      maxDepth: 1,
      preferredPath: typeof cliOptions.config === "string" ? cliOptions.config : undefined,
      packageJsonProperty: "bunup"
    });
  }
  const { config, filepath } = loadedConfig ?? {};
  const configsToProcess = !config ? [{ rootDir: cwd, options: cliOptions }] : await processLoadedConfigs(config, cwd, cliOptions.filter);
  const shouldSilent = cliOptions.watch || cliOptions.silent || configsToProcess.some((c) => ensureArray(c.options).some((o) => o.silent));
  if (shouldSilent) {
    logger.setSilent(true);
  }
  logger.info(`Using bunup v${version} and bun v${Bun.version}`, {
    muted: true
  });
  if (filepath) {
    logger.info(`Using ${getShortFilePath(filepath, 2)}`, {
      muted: true
    });
  }
  logger.info("Build started");
  const startTime = performance.now();
  const buildResults = [];
  await Promise.all(configsToProcess.flatMap(({ options, rootDir }) => {
    const optionsArray = ensureArray(options);
    return optionsArray.map(async (o) => {
      const userOptions = {
        ...o,
        ...removeCliOnlyOptions(cliOptions)
      };
      if (userOptions.watch) {
        await watch(userOptions, rootDir, filepath);
      } else {
        buildResults.push(await build(userOptions, rootDir));
      }
    });
  }));
  const buildTimeMs = performance.now() - startTime;
  if (!cliOptions.watch && !shouldSilent) {
    await Promise.all(buildResults.map((o) => printBuildReport(o)));
  }
  if (cliOptions.watch) {
    console.log(`
  ${pc4.bgMagentaBright(" WATCH ")} Watching for file changes...
`);
  }
  logger.space();
  logger.success(`Build completed in ${pc4.green(logTime(buildTimeMs))}`);
}
var CLI_ONLY_OPTIONS = ["config", "filter"];
function removeCliOnlyOptions(options) {
  const cleanedOptions = { ...options };
  for (const option of CLI_ONLY_OPTIONS) {
    delete cleanedOptions[option];
  }
  return cleanedOptions;
}
main().catch((error) => handleErrorAndExit(error));
