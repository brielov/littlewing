// @bun
import {
  ensureArray,
  exports,
  injectStyles,
  isGlobPattern,
  logger,
  shims,
  unused
} from "./shared/bunup-qb65sm3k.js";

// packages/bunup/src/plugins/copy.ts
import { basename, extname, join } from "path";
function copy(pattern) {
  return new CopyBuilder(pattern);
}

class CopyBuilder {
  _patterns;
  _destination;
  _options;
  _transform;
  _fileCache = new Map;
  constructor(pattern) {
    this._patterns = ensureArray(pattern);
  }
  to(destination) {
    this._destination = destination;
    return this;
  }
  with(options) {
    this._options = options;
    return this;
  }
  transform(fn) {
    this._transform = fn;
    return this;
  }
  get name() {
    return "copy";
  }
  get hooks() {
    return {
      onBuildDone: async ({ options: buildOptions, meta }) => {
        const isWatchMode = buildOptions.watch;
        const watchBehavior = this._options?.watchMode ?? "changed";
        if (isWatchMode && watchBehavior === "skip") {
          return;
        }
        let destinationPath = "";
        if (this._destination) {
          if (this._destination.startsWith(buildOptions.outDir)) {
            logger.warn("  You don't need to include the output directory in the destination path for the copy plugin. Files are copied to the output directory by default.", {
              verticalSpace: true
            });
            destinationPath = this._destination;
          } else {
            destinationPath = join(buildOptions.outDir, this._destination);
          }
        } else {
          destinationPath = buildOptions.outDir;
        }
        const activeFiles = new Set;
        for (const pattern of this._patterns) {
          const glob = new Bun.Glob(pattern);
          for await (const scannedPath of glob.scan({
            cwd: meta.rootDir,
            dot: !this._options?.excludeDotfiles,
            onlyFiles: isGlobPattern(pattern),
            followSymlinks: this._options?.followSymlinks
          })) {
            const sourcePath = join(meta.rootDir, scannedPath);
            activeFiles.add(sourcePath);
            if (isWatchMode && watchBehavior === "changed") {
              const stat = await Bun.file(sourcePath).stat();
              const lastModified = stat?.mtime?.getTime() ?? 0;
              const cachedTime = this._fileCache.get(sourcePath);
              if (cachedTime === lastModified) {
                continue;
              }
              this._fileCache.set(sourcePath, lastModified);
            }
            const finalDestinationPath = resolveDestinationPath(destinationPath, scannedPath, meta.rootDir);
            const shouldOverride = this._options?.override ?? true;
            if (!shouldOverride) {
              const destinationExists = await Bun.file(finalDestinationPath).exists();
              if (destinationExists) {
                continue;
              }
            }
            if (isDirectoryPath(sourcePath)) {
              await copyDirectory(sourcePath, finalDestinationPath);
            } else {
              await this.copyFileWithTransform(sourcePath, finalDestinationPath, buildOptions);
            }
          }
        }
        if (isWatchMode && watchBehavior === "changed") {
          for (const cachedPath of this._fileCache.keys()) {
            if (!activeFiles.has(cachedPath)) {
              this._fileCache.delete(cachedPath);
            }
          }
        }
      }
    };
  }
  async copyFileWithTransform(sourcePath, destinationPath, buildOptions) {
    const sourceFile = Bun.file(sourcePath);
    if (this._transform) {
      const content = await sourceFile.arrayBuffer();
      const result = await this._transform({
        content,
        path: sourcePath,
        destination: destinationPath,
        options: buildOptions
      });
      if (typeof result === "object" && "content" in result && "filename" in result) {
        const newDestination = join(destinationPath.substring(0, destinationPath.lastIndexOf("/")), result.filename);
        await Bun.write(newDestination, result.content);
      } else {
        await Bun.write(destinationPath, result);
      }
    } else {
      await Bun.write(destinationPath, sourceFile);
    }
  }
}
function resolveDestinationPath(destinationPath, scannedPath, rootDir) {
  const fullDestinationPath = join(rootDir, destinationPath);
  const isScannedPathDir = isDirectoryPath(scannedPath);
  const isDestinationDir = isDirectoryPath(fullDestinationPath);
  if (isDestinationDir && !isScannedPathDir) {
    return join(fullDestinationPath, basename(scannedPath));
  }
  return fullDestinationPath;
}
function isDirectoryPath(filePath) {
  return extname(filePath) === "";
}
async function copyDirectory(sourcePath, finalDestinationPath) {
  await Bun.$`cp -r ${sourcePath} ${finalDestinationPath}`;
}
export {
  unused,
  shims,
  injectStyles,
  exports,
  copy
};
