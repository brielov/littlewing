import { GenerateDtsOptions } from "@bunup/dts";
import { BunPlugin as BunPlugin2, CompileBuildOptions } from "bun";
type PackageJson = {
	/** The parsed content of the package.json file */
	data: Record<string, any> | null;
	/** The path to the package.json file */
	path: string | null;
};
/**
* Represents the meta data of the build
*/
type BuildMeta = {
	/** The package.json file */
	packageJson: PackageJson;
	/** The root directory of the build */
	rootDir: string;
};
type BuildOutputFile = {
	/**
	* The entry point for which this file was generated
	*
	* Undefined for non-entry point files (e.g., assets, sourcemaps, chunks)
	*/
	entrypoint: string | undefined;
	/** The kind of the file */
	kind: "entry-point" | "chunk" | "asset" | "sourcemap" | "bytecode" | "executable";
	/** Absolute path to the generated file */
	fullPath: string;
	/** Path to the generated file relative to the root directory */
	pathRelativeToRootDir: string;
	/** Path to the generated file relative to the output directory */
	pathRelativeToOutdir: string;
	/** Whether the file is a dts file */
	dts: boolean;
	/** The format of the output file */
	format: Format;
	/** The size of the file in bytes */
	size: number;
};
/**
* Build configuration and metadata used during build execution.
*/
type BuildContext = {
	/** Build configuration options that were used */
	options: BuildOptions;
	/** Build execution metadata */
	meta: BuildMeta;
};
/**
* Build output containing generated files and build context.
*/
type BuildResult = {
	/** Generated output files */
	files: BuildOutputFile[];
	/** Build configuration and metadata that were used */
	build: BuildContext;
};
/**
* Context provided when build starts.
*/
type OnBuildStartCtx = {
	/** Build configuration options that will be used */
	options: BuildOptions;
};
/**
* Context provided when build completes.
* Flattened structure for easy access in plugin hooks.
*/
type OnBuildDoneCtx = {
	/** Generated output files */
	files: BuildOutputFile[];
	/** Build configuration options that were used */
	options: BuildOptions;
	/** Build execution metadata */
	meta: BuildMeta;
};
/**
* Hooks that can be implemented by Bunup plugins.
*/
type BunupPluginHooks = {
	/**
	* Called when a build is successfully completed.
	*/
	onBuildDone?: (ctx: OnBuildDoneCtx) => MaybePromise<void>;
	/**
	* Called before a build starts.
	*/
	onBuildStart?: (ctx: OnBuildStartCtx) => MaybePromise<void>;
};
/**
* Represents a Bunup-specific plugin
*/
type BunupPlugin = {
	/** Optional name for the plugin */
	name?: string;
	/** The hooks implemented by this plugin */
	hooks: BunupPluginHooks;
};
type CustomExports = Record<string, string | Record<string, string | Record<string, string>>>;
type Exclude2 = ((ctx: BuildContext) => string[] | undefined) | string[];
interface ExportsOptions {
	/**
	* Additional fields to preserve alongside automatically generated exports
	*
	* @see https://bunup.dev/docs/extra-options/exports#customexports
	*/
	customExports?: (ctx: BuildContext) => CustomExports | undefined;
	/**
	* Export keys to exclude from the generated exports field in package.json
	*
	* This option filters out specific keys from the final exports object
	* after all exports have been internally generated. Use glob patterns or exact
	* key strings (e.g., ".", "./utils", "./components/*") to match the
	* keys you want to exclude.
	*
	* @example
	* ```ts
	* // Exclude specific keys
	* exclude: ["./internal", "./utils"]
	*
	* // Exclude using glob patterns
	* exclude: ["./internal/*", "./private-*"]
	*
	* // Dynamic exclusion based on build context
	* exclude: (ctx) => {
	*   return ["./debug"]
	* }
	* ```
	*
	* @see https://bunup.dev/docs/extra-options/exports#exclude
	*/
	exclude?: Exclude2;
	/**
	* Whether to automatically exclude CLI entry points from the exports field
	*
	* When enabled (default), CLI-related entry points are automatically excluded
	* from package exports since they are typically used for binaries and should
	* not be exposed as importable package exports.
	*
	* The plugin uses glob patterns to match common CLI entry point patterns:
	* - Files or directories named "cli" (e.g., `cli.ts`, `cli/index.ts`)
	* - Files or directories named "bin" (e.g., `bin.ts`, `bin/index.ts`)
	* - CLI-related paths in src directory (e.g., `src/cli.ts`, `src/bin/index.ts`)
	*
	* If you want to include CLI entries in your exports, set this to `false` and
	* optionally use the `exclude` option for more granular control.
	*
	* @default true
	* @see https://bunup.dev/docs/extra-options/exports#excludecli
	*/
	excludeCli?: boolean;
	/**
	* Whether to exclude CSS files from being added to the exports field
	*
	* @default false
	*/
	excludeCss?: boolean;
	/**
	* Whether to include "./package.json": "./package.json" in the exports field
	*
	* @default true
	* @see https://bunup.dev/docs/extra-options/exports#includepackagejson
	*/
	includePackageJson?: boolean;
	/**
	* Whether to add a wildcard that allows deep imports
	*
	* When true, adds "./*": "./*" to exports, making all files accessible
	* When false (default), only explicit exports are accessible
	*
	* @default false
	* @see https://bunup.dev/docs/extra-options/exports#all
	*/
	all?: boolean;
}
/**
* A plugin that generates the exports field in the package.json file automatically.
*
* @see https://bunup.dev/docs/extra-options/exports
*/
declare function exports(options?: ExportsOptions): BunupPlugin;
import { BunPlugin } from "bun";
type InjectStylesOptions = {
	/**
	* Custom function to inject CSS into the document head.
	*
	* By default, bunup uses its own `injectStyle` function that creates a `<style>`
	* tag and appends it to the document head. You can provide your own injection
	* logic to customize how styles are applied to the document.
	*
	* @param css - The processed CSS string (already JSON stringified)
	* @param filePath - The original file path of the CSS file being processed
	* @returns JavaScript code that will inject the styles when executed
	*
	* @example
	* ```ts
	* injectStyles({
	*   inject: (css, filePath) => {
	*     return `
	*       const style = document.createElement('style');
	*       style.setAttribute('data-source', '${filePath}');
	*       style.textContent = ${css};
	*       document.head.appendChild(style);
	*     `;
	*   }
	* })
	* ```
	*
	* The default injection handles cases like when `document` is undefined (e.g., server-side rendering) and compatibility with older browsers. Consider these when implementing custom injection logic.
	*/
	inject?: (css: string, filePath: string) => MaybePromise<string>;
	/**
	* Whether to minify the styles being injected.
	*
	* @default true
	*/
	minify?: boolean;
};
/**
* A plugin that injects styles into the document head at runtime instead of bundling them to the build output.
*
* @see https://bunup.dev/docs/extra-options/inject-styles
*/
declare function injectStyles(options?: InjectStylesOptions): BunPlugin;
interface UnusedOptions {
	/**
	* The level of reporting for unused or incorrectly categorized dependencies
	* @default 'warn'
	*/
	level?: "warn" | "error";
	/**
	* Dependencies to ignore when checking
	* @default []
	*/
	ignore?: string[];
}
/**
* Detects and reports unused or incorrectly categorized dependencies in your project,
* helping you maintain a clean dependency tree and keep your `package.json` up to date.
*
* @see https://bunup.dev/docs/extra-options/unused
*/
declare function unused(options?: UnusedOptions): BunupPlugin;
type Loader = "js" | "jsx" | "ts" | "tsx" | "json" | "toml" | "file" | "napi" | "wasm" | "text" | "css" | "html";
type Define = Record<string, string>;
type Sourcemap = "none" | "linked" | "inline" | "external" | "linked" | boolean;
type Format = "esm" | "cjs" | "iife";
type Target = "bun" | "node" | "browser";
type External = (string | RegExp)[];
type Env = "inline" | "disable" | `${string}*` | Record<string, string>;
type CSSOptions = {
	/**
	* Generate TypeScript definitions for CSS modules.
	*
	* @see https://bunup.dev/docs/guide/css#css-modules-and-typescript
	*/
	typedModules?: boolean;
	/**
	* Inject CSS styles into the document head at runtime instead of bundling them to the build output.
	*
	* When `true`, enables CSS injection with default settings.
	* When an object is provided, allows customization of the injection behavior.
	*
	* @see https://bunup.dev/docs/extra-options/inject-styles
	*/
	inject?: boolean | InjectStylesOptions;
};
type Compile = boolean | Bun.Build.Target | CompileBuildOptions;
type OnSuccess = ((options: Partial<BuildOptions>) => MaybePromise<void> | (() => void)) | string | {
	/**
	* The shell command to execute after a successful build
	*/
	cmd: string;
	/**
	* Additional options for the command execution
	*/
	options?: {
		/**
		* Working directory for the command
		*/
		cwd?: string;
		/**
		* Environment variables to pass to the command
		* @default process.env
		*/
		env?: Record<string, string | undefined>;
		/**
		* Maximum time in milliseconds the command is allowed to run
		*/
		timeout?: number;
		/**
		* Signal to use when killing the process
		* @default 'SIGTERM'
		*/
		killSignal?: NodeJS.Signals | number;
	};
};
type ReportOptions = {
	/**
	* Enable gzip compression size calculation.
	*
	* Note: For huge output files, this may slow down the build process. In this case, consider disabling this option.
	*
	* @default true
	*/
	gzip?: boolean;
	/**
	* Enable brotli compression size calculation.
	*
	* Note: For huge output files, this may slow down the build process. In this case, consider disabling this option.
	*
	* @default false
	*/
	brotli?: boolean;
	/**
	* Maximum bundle size in bytes. Will warn if exceeded.
	*
	* @default undefined
	*/
	maxBundleSize?: number;
};
type JSXOptions = {
	/**
	* JSX runtime mode
	* @default "automatic"
	*/
	runtime?: "automatic" | "classic";
	/**
	* Import source for JSX functions
	* @default "react"
	* @example "preact"
	*/
	importSource?: string;
	/**
	* JSX factory function name
	* @default "React.createElement"
	* @example "h"
	*/
	factory?: string;
	/**
	* JSX fragment function name
	* @default "React.Fragment"
	* @example "Fragment"
	*/
	fragment?: string;
	/**
	* Whether JSX functions have side effects
	* @default false
	*/
	sideEffects?: boolean;
	/**
	* Use jsx-dev runtime for development
	* @default false
	*/
	development?: boolean;
};
interface BuildOptions {
	/**
	* Name of the build configuration
	* Used for logging and identification purposes
	*/
	name?: string;
	/**
	* Entry point files for the build
	*
	* This can be:
	* - A string path to a file
	* - An array of file paths
	*
	* @see https://bunup.dev/docs/guide/options#entry-points
	*/
	entry: Arrayable<string>;
	/**
	* Output directory for the bundled files
	* Defaults to 'dist' if not specified
	*/
	outDir: string;
	/**
	* Output formats for the bundle
	* Can include 'esm', 'cjs', and/or 'iife'
	* Defaults to 'esm' if not specified
	*/
	format: Format | Format[];
	/**
	* Whether to enable all minification options
	* When true, enables minifyWhitespace, minifyIdentifiers, and minifySyntax
	*/
	minify?: boolean;
	/**
	* Whether to enable code splitting
	* Defaults to true for ESM format, false for CJS format
	*/
	splitting?: boolean;
	/**
	* Whether to minify whitespace in the output
	* Removes unnecessary whitespace to reduce file size
	*/
	minifyWhitespace?: boolean;
	/**
	* Whether to minify identifiers in the output
	* Renames variables and functions to shorter names
	*/
	minifyIdentifiers?: boolean;
	/**
	* Whether to minify syntax in the output
	* Optimizes code structure for smaller file size
	*/
	minifySyntax?: boolean;
	/**
	* Whether to watch for file changes and rebuild automatically
	*/
	watch?: boolean;
	/**
	* package.json `exports` conditions used when resolving imports
	*
	* Equivalent to `--conditions` in `bun build` or `bun run`.
	*
	* https://nodejs.org/api/packages.html#exports
	*/
	conditions?: Arrayable<string>;
	/**
	* Whether to generate TypeScript declaration files (.d.ts)
	* When set to true, generates declaration files for all entry points
	* Can also be configured with GenerateDtsOptions for more control
	*/
	dts?: boolean | (Pick<GenerateDtsOptions, "resolve" | "splitting" | "minify" | "inferTypes" | "tsgo"> & {
		entry?: Arrayable<string>;
	});
	/**
	* Path to a custom tsconfig.json file used for path resolution during
	* both bundling and TypeScript declaration generation.
	*
	* If not specified, the nearest tsconfig.json will be used.
	*
	* @example
	* preferredTsconfig: './tsconfig.build.json'
	*/
	preferredTsconfig?: string;
	/**
	* External packages that should not be bundled
	* Useful for dependencies that should be kept as external imports
	*/
	external?: External;
	/**
	* Packages that should be bundled even if they are in external
	* Useful for dependencies that should be included in the bundle
	*/
	noExternal?: External;
	/**
	* Controls whether to bundle or externalize all dependencies.
	*
	* This option provides a convenient way to handle all dependencies at once:
	* - `"bundle"`: Bundle all dependencies into the output (overrides automatic external behavior)
	* - `"external"`: Externalize all dependencies (treats all as external)
	*
	* This option works alongside `external` and `noExternal`:
	* - When set to `"bundle"`, all dependencies are bundled by default, but `external` can still mark specific packages as external
	* - When set to `"external"`, all dependencies are externalized by default, but `noExternal` can still bundle specific packages
	*
	* @see https://bunup.dev/docs/guide/options#managing-dependencies-in-your-bundle
	*
	* @example
	* // Bundle all dependencies
	* packages: "bundle"
	*
	* @example
	* // Externalize all dependencies
	* packages: "external"
	*/
	packages?: "bundle" | "external";
	/**
	* The target environment for the bundle.
	* Can be 'browser', 'bun', 'node', etc.
	* Defaults to 'node' if not specified.
	*
	* Bun target is for generating bundles that are intended to be run by the Bun runtime. In many cases,
	* it isn't necessary to bundle server-side code; you can directly execute the source code
	* without modification. However, bundling your server code can reduce startup times and
	* improve running performance.
	*
	* All bundles generated with `target: "bun"` are marked with a special `// @bun` pragma, which
	* indicates to the Bun runtime that there's no need to re-transpile the file before execution.
	*/
	target?: Target;
	/**
	* Whether to clean the output directory before building
	* When true, removes all files in the outDir before starting a new build
	* Defaults to true if not specified
	*/
	clean?: boolean;
	/**
	* Specifies the type of sourcemap to generate
	* Can be 'none', 'linked', 'external', or 'inline'
	* Can also be a boolean - when true, it will use 'inline'
	*
	* @see https://bun.com/docs/bundler#sourcemap
	*
	* @default 'none'
	*
	* @example
	* sourcemap: 'linked'
	* // or
	* sourcemap: true // equivalent to 'inline'
	*/
	sourcemap?: Sourcemap;
	/**
	* Define global constants for the build
	* These values will be replaced at build time
	*
	* @see https://bun.com/docs/bundler#define
	*
	* @example
	* define: {
	*   'process.env.NODE_ENV': '"production"',
	*   'PACKAGE_VERSION': '"1.0.0"'
	* }
	*/
	define?: Define;
	/**
	* A callback or command to run after a successful build.
	*
	* If a function is provided, it can optionally return a cleanup function
	* that will be called when the operation is cancelled.
	*
	* @example
	* onSuccess: (options) => {
	*   const server = startServer();
	*   return () => server.close();
	* }
	*
	* @example
	* onSuccess: "echo Build completed!"
	*
	* @example
	* onSuccess: {
	*   cmd: "bun run dist/server.js",
	*   options: { env: { ...process.env, FOO: "bar" } }
	* }
	*/
	onSuccess?: OnSuccess;
	/**
	* A banner to be added to the final bundle, this can be a directive like "use client" for react or a comment block such as a license for the code.
	*
	* @see https://bun.com/docs/bundler#banner
	*
	* @example
	* banner: '"use client";'
	*/
	banner?: string;
	/**
	* A footer to be added to the final bundle, this can be something like a comment block for a license or just a fun easter egg.
	*
	* @see https://bun.com/docs/bundler#footer
	*
	* @example
	* footer: '// built with love in SF'
	*/
	footer?: string;
	/**
	* Remove function calls from a bundle. For example, `drop: ["console"]` will remove all calls to `console.log`. Arguments to calls will also be removed, regardless of if those arguments may have side effects. Dropping `debugger` will remove all `debugger` statements.
	*
	* @see https://bun.com/docs/bundler#drop
	*
	* @example
	* drop: ["console", "debugger", "anyIdentifier.or.propertyAccess"]
	*/
	drop?: string[];
	/**
	* A map of file extensions to [built-in loader names](https://bun.com/docs/bundler/loaders#built-in-loaders). This can be used to quickly customize how certain files are loaded.
	*
	* @see https://bun.com/docs/bundler#loader
	*
	* @example
	* loader: {
	*   ".png": "dataurl",
	*   ".txt": "file",
	* }
	*/
	loader?: { [k in string] : Loader };
	/**
	* Disable logging during the build process. When set to true, no logs will be printed to the console.
	*
	* @default false
	*/
	silent?: boolean;
	/**
	* You can specify a prefix to be added to specific import paths in your bundled code
	*
	* Used for assets, external modules, and chunk files when splitting is enabled
	*
	* @see https://bunup.dev/docs/guide/options#public-path for more information
	*
	* @example
	* publicPath: 'https://cdn.example.com/'
	*/
	publicPath?: string;
	/**
	* The base directory for your entry points to control the output file structure.
	*
	* Sets the base directory from which relative paths are calculated.
	* Preserves your source directory structure in the output.
	* If not specified, Bunup automatically uses the lowest common ancestor directory of all entry points.
	*
	* @see https://bun.com/docs/bundler#root
	*
	* @example
	* sourceBase: './src'
	*/
	sourceBase?: string;
	/**
	* Controls how environment variables are handled during bundling.
	*
	* Can be one of:
	* - `"inline"`: Replaces all `process.env.FOO` references in your code with the actual values
	*   of those environment variables at the time the build runs.
	* - `"disable"`: Disables environment variable injection entirely, leaving `process.env.*` as-is.
	* - A string ending in `*`: Only inlines environment variables matching the given prefix.
	*   For example, `"MY_PUBLIC_*"` will inline variables like `MY_PUBLIC_API_URL`.
	* - An object of key-value pairs: Replaces both `process.env.KEY` and `import.meta.env.KEY`
	*   with the provided values, regardless of the runtime environment.
	*
	* Note: Values are injected at build time. Secrets or private keys should be excluded
	* from inlining when targeting browser environments.
	*
	* @see https://bun.com/docs/bundler#env to learn more about inline, disable, prefix, and object modes
	*
	* @example
	* // Inline all environment variables available at build time
	* env: "inline"
	*
	* // Disable all environment variable injection
	* env: "disable"
	*
	* // Only inline environment variables with a specific prefix
	* env: "PUBLIC_*"
	*
	* // Provide specific environment variables manually
	* env: { API_URL: "https://api.example.com", DEBUG: "false" }
	*/
	env?: Env;
	/**
	* Ignore dead code elimination/tree-shaking annotations such as @__PURE__ and package.json
	* "sideEffects" fields. This should only be used as a temporary workaround for incorrect
	* annotations in libraries.
	*/
	ignoreDCEAnnotations?: boolean;
	/**
	* Force emitting @__PURE__ annotations even if minify.whitespace is true.
	*/
	emitDCEAnnotations?: boolean;
	/**
	* Plugins to extend the build process functionality
	*
	* The Plugin type uses a discriminated union pattern with the 'type' field
	* to support different plugin systems. Both "bun" and "bunup" plugins are supported.
	*
	* Each plugin type has its own specific plugin implementation:
	* - "bun": Uses Bun's native plugin system (BunPlugin)
	* - "bunup": Uses bunup's own plugin system with lifecycle hooks
	*
	* This architecture allows for extensibility as more plugin systems are added.
	*
	* @see https://bunup.dev/docs/advanced/plugin-development for more information on plugins
	*
	* @example
	* plugins: [
	* 	myBunPlugin(),
	*   {
	*     name: "my-bunup-plugin",
	*     hooks: {
	*       onBuildStart: (options) => {
	*         console.log('Build started with options:', options)
	*       },
	*       onBuildDone: ({ options, output }) => {
	*         console.log('Build completed with output:', output)
	*       }
	*     }
	*   }
	* ]
	*/
	plugins?: (BunupPlugin | BunPlugin2)[];
	/**
	* Configure JSX transform behavior. Allows fine-grained control over how JSX is compiled.
	*/
	jsx?: JSXOptions;
	/**
	* Options for CSS handling in the build process.
	*/
	css?: CSSOptions;
	/**
	* Whether to enable shims for Node.js globals and ESM/CJS interoperability.
	*
	* @default false
	*/
	shims?: boolean;
	/**
	* Configuration for the build report that shows file sizes and compression stats.
	*/
	report?: ReportOptions;
	/**
	* Automatically generate the exports field in package.json based on build outputs.
	*
	* When `true`, enables automatic exports generation with default settings.
	* When an object is provided, allows customization of generation behavior,
	* including custom exports, exclusions, and package.json inclusion options.
	*
	* @see https://bunup.dev/docs/extra-options/exports
	*/
	exports?: boolean | ExportsOptions;
	/**
	* Detect and report dependencies that are unused or incorrectly categorized.
	* This includes dependencies not used in your build output, as well as dependencies
	* that don't need to be packed with your library.
	*
	* @see https://bunup.dev/docs/extra-options/unused
	*/
	unused?: boolean | UnusedOptions;
	/**
	* Create a standalone executable from your code.
	*
	* When `true`, creates an executable for the current platform.
	* When a target string is provided, creates an executable for that specific platform.
	* When an object is provided, allows for advanced configuration including cross-compilation options.
	*
	* @see https://bunup.dev/docs/advanced/compile
	*
	* @example
	* // Create executable for current platform
	* compile: true
	*
	* @example
	* // Cross-compile for Linux x64
	* compile: 'bun-linux-x64'
	*
	* @example
	* // Advanced configuration with options
	* compile: {
	*   target: 'bun-linux-x64',
	*   outfile: './my-cli',
	*   windows: {
	*     hideConsole: true,
	*     icon: './icon.ico'
	*   }
	* }
	*/
	compile?: Compile;
}
type MaybePromise<T> = Promise<T> | T;
type WithOptional<
	T,
	K extends keyof T
> = Omit<T, K> & Partial<Pick<T, K>>;
type WithRequired<
	T,
	K extends keyof T
> = Omit<T, K> & Required<Pick<T, K>>;
type Arrayable<T> = T | T[];
type DefineConfigItem = WithOptional<BuildOptions, "outDir" | "format" | "entry">;
type DefineWorkspaceItem = {
	name: string;
	root: string;
	config?: DefineConfigItem | WithRequired<DefineConfigItem, "name">[];
};
export { WithOptional, WithRequired, Arrayable, DefineConfigItem, DefineWorkspaceItem, BuildMeta, BuildOutputFile, BuildContext, BuildResult, BunupPluginHooks, BunupPlugin, exports, injectStyles, unused, BuildOptions };
