// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __require = import.meta.require;

// packages/bunup/src/printer/logger.ts
import pc from "picocolors";

class Logger {
  static instance;
  loggedOnceMessages = new Set;
  silent = false;
  constructor() {}
  static getInstance() {
    if (!Logger.instance) {
      Logger.instance = new Logger;
    }
    return Logger.instance;
  }
  setSilent(value) {
    this.silent = value ?? false;
  }
  isSilent() {
    return this.silent;
  }
  shouldLog(options) {
    if (!options?.once) {
      return true;
    }
    if (this.loggedOnceMessages.has(options.once)) {
      return false;
    }
    this.loggedOnceMessages.add(options.once);
    return true;
  }
  getIcon(type, tick) {
    if (tick) {
      return pc.green("\u2713");
    }
    const iconMap = {
      info: pc.blue("i"),
      warn: pc.yellow("!"),
      error: pc.red("\u2715")
    };
    return iconMap[type];
  }
  formatIdentifier(identifier) {
    return identifier ? `   ${pc.bgBlueBright(` ${identifier} `)}` : "";
  }
  formatMessage(options) {
    const {
      message,
      identifier,
      muted = false,
      tick = false,
      type = "info",
      noIcon = false,
      leftPadding
    } = options;
    const icon = noIcon ? "" : options.icon ?? this.getIcon(type, tick);
    const styledMessage = muted ? pc.dim(message) : type === "error" ? pc.red(message) : type === "warn" ? pc.yellow(message) : message;
    const identifierPart = this.formatIdentifier(identifier);
    const iconPart = icon ? `${icon} ` : "";
    const baseMessage = `${iconPart}${styledMessage}${identifierPart}`;
    const paddingCount = leftPadding === true ? 2 : typeof leftPadding === "number" ? leftPadding : 0;
    if (paddingCount > 0) {
      const padding = " ".repeat(paddingCount);
      return baseMessage.split(`
`).map((line) => `${padding}${line}`).join(`
`);
    }
    return baseMessage;
  }
  output(message, options = {}, logFn = console.log) {
    if (this.silent || !this.shouldLog(options)) {
      return;
    }
    if (options.verticalSpace) {
      logFn("");
    }
    logFn(message);
    if (options.verticalSpace) {
      logFn("");
    }
  }
  info(message, options = {}) {
    const formattedMessage = this.formatMessage({
      ...options,
      message,
      type: "info"
    });
    this.output(formattedMessage, options);
  }
  warn(message, options = {}) {
    const formattedMessage = this.formatMessage({
      ...options,
      message,
      type: "warn"
    });
    this.output(formattedMessage, options);
  }
  error(message, options = {}) {
    const formattedMessage = this.formatMessage({
      ...options,
      message,
      type: "error"
    });
    this.output(formattedMessage, options);
  }
  success(message, options = {}) {
    const formattedMessage = this.formatMessage({
      ...options,
      message,
      tick: true
    });
    this.output(formattedMessage, options);
  }
  space() {
    if (!this.silent) {
      console.log("");
    }
  }
  log(message, options = {}) {
    const formattedMessage = this.formatMessage({
      ...options,
      message,
      type: "info",
      noIcon: true
    });
    this.output(formattedMessage, options);
  }
  list(items, options) {
    return items.map((item) => {
      const bullet = pc.cyan("-");
      const text = options?.dim ? pc.dim(item) : item;
      return `  ${bullet} ${text}`;
    }).join(`
`);
  }
  highlight(code) {
    const keywords = /\b(const|let|var|function|return|if|else|for|while|class|import|export|from|async|await|new|try|catch|throw|typeof|interface|type|enum)\b/g;
    const strings = /(["'`])(?:(?=(\\?))\2.)*?\1/g;
    const comments = /(\/\/.*$|\/\*[\s\S]*?\*\/)/gm;
    const numbers = /\b(\d+\.?\d*)\b/g;
    const functions = /\b([a-zA-Z_$][a-zA-Z0-9_$]*)\s*(?=\()/g;
    let result = code;
    result = result.replace(comments, (match) => pc.dim(match));
    result = result.replace(strings, (match) => pc.green(match));
    result = result.replace(keywords, (match) => pc.magenta(match));
    result = result.replace(numbers, (match) => pc.yellow(match));
    result = result.replace(functions, (match) => pc.cyan(match));
    return result;
  }
}
function logTime(ms) {
  return ms >= 1000 ? pc.green(`${(ms / 1000).toFixed(2)}s`) : pc.green(`${Math.round(ms)}ms`);
}
function link(url, label) {
  if (!label) {
    label = url;
  }
  return `\x1B]8;;${url}\x07${pc.underline(pc.cyan(label))}\x1B]8;;\x07`;
}
var logger = Logger.getInstance();

// packages/bunup/src/utils/path.ts
import { normalize } from "path";
function getShortFilePath(filePath, maxLength = 3) {
  const fileParts = filePath.split("/");
  const shortPath = fileParts.slice(-maxLength).join("/");
  return shortPath;
}
function cleanPath(path) {
  return normalize(path).replace(/\\/g, "/").replace(/^[a-zA-Z]:\//, "").replace(/^\/+/, "").replace(/\/+/g, "/");
}

// packages/bunup/src/errors.ts
import pc2 from "picocolors";

// packages/bunup/src/utils/format.ts
function formatFileSize(bytes) {
  if (bytes === 0)
    return "0 B";
  const units = ["B", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  if (i === 0)
    return `${bytes} ${units[i]}`;
  return `${(bytes / 1024 ** i).toFixed(2)} ${units[i]}`;
}
var listFormatter = new Intl.ListFormat("en", {
  style: "long",
  type: "conjunction"
});
function formatListWithAnd(arr) {
  return listFormatter.format(arr);
}
function stripAnsiSafe(text) {
  return Bun.stripANSI ? Bun.stripANSI(text) : text;
}

// packages/bunup/src/errors.ts
class BunupError extends Error {
  constructor(message) {
    super(message);
    this.name = "BunupError";
  }
}

class BunupBuildError extends BunupError {
  constructor(message) {
    super(message);
    this.name = "BunupBuildError";
  }
}

class BunupDTSBuildError extends BunupError {
  constructor(message) {
    super(message);
    this.name = "BunupDTSBuildError";
  }
}

class BunupCLIError extends BunupError {
  constructor(message) {
    super(message);
    this.name = "BunupCLIError";
  }
}

class BunupWatchError extends BunupError {
  constructor(message) {
    super(message);
    this.name = "BunupWatchError";
  }
}

class BunupPluginError extends BunupError {
  constructor(message) {
    super(message);
    this.name = "BunupPluginError";
  }
}

class BunupVersionError extends BunupError {
  constructor(message) {
    super(message);
    this.name = "BunupVersionError";
  }
}
var parseErrorMessage = (error) => {
  if (error instanceof Error) {
    return error.message;
  }
  return String(error);
};
var KNOWN_ERRORS = [
  {
    pattern: /Could not resolve: "bun"/i,
    errorType: "BUILD ERROR",
    logSolution: () => {
      logger.log("You're trying to build a project that uses Bun. " + "Please set the target option to " + pc2.cyan("`bun`") + `.
` + "Example: " + pc2.green("`bunup --target bun`") + " or in config: " + pc2.green("{ target: 'bun' }"));
    }
  },
  {
    pattern: /has already been exported. Exported identifiers must be unique./i,
    errorType: "DTS ERROR",
    logSolution: () => {
      logger.log("An error occurred while bundling dts files. This issue occurs when dts splitting is enabled due to a bug in the Bun bundler. Please ping the GitHub issue to help get it fixed faster: " + link("https://github.com/oven-sh/bun/issues/5344") + ". To fix this issue for now, you can disable dts splitting by removing " + pc2.dim("dts: { splitting: true }") + " from your config." + " You can re-enable it once the issue is fixed.");
    }
  }
];
var handleError = (error, context) => {
  const errorMessage = parseErrorMessage(error);
  const contextPrefix = context ? `[${context}] ` : "";
  let errorType = "UNKNOWN ERROR";
  if (error instanceof BunupBuildError) {
    errorType = "BUILD ERROR";
  } else if (error instanceof BunupDTSBuildError) {
    errorType = "DTS ERROR";
  } else if (error instanceof BunupCLIError) {
    errorType = "CLI ERROR";
  } else if (error instanceof BunupWatchError) {
    errorType = "WATCH ERROR";
  } else if (error instanceof BunupPluginError) {
    errorType = "PLUGIN ERROR";
  } else if (error instanceof BunupVersionError) {
    errorType = "VERSION ERROR";
  } else if (error instanceof BunupError) {
    errorType = "BUNUP ERROR";
  }
  const knownError = KNOWN_ERRORS.find((error2) => error2.pattern.test(errorMessage) && (error2.errorType === errorType || !error2.errorType));
  if (!knownError) {
    logger.error(`
${pc2.bgRed(` ${errorType} `)}

${contextPrefix}${errorMessage}`, { noIcon: true, leftPadding: true });
  }
  if (knownError) {
    logger.space();
    knownError.logSolution(errorMessage);
    logger.space();
  } else {
    const issueUrl = new URL("https://github.com/bunup/bunup/issues/new");
    issueUrl.searchParams.set("title", `[${errorType}] [give a descriptive title]`);
    issueUrl.searchParams.set("body", `## Error Details

**Error Type:** ${errorType}
**Error Message:** ${stripAnsiSafe(errorMessage)}

## Additional Context

<!-- Please provide any additional context about what you were trying to do when the error occurred -->`);
    logger.log(pc2.white(`
  If you think this is a bug, please `) + link(issueUrl.toString(), "open an issue") + ` with details about this error
`);
  }
};
var formatNoEntryPointsFoundError = (defaultEntrypoints) => {
  return `${pc2.red(pc2.bold("No entry points found"))}

` + `Looked for these default entry points:

` + logger.list(defaultEntrypoints, { dim: true }) + `

You can specify entry points via CLI like ${pc2.green("bunup lib/main.ts")}, ` + `use multiple entries like ${pc2.green("bunup components/button.tsx utils/format.ts")}, or add the entry option in your bunup config.`;
};
var formatInvalidEntryPointsError = (userEntrypoints) => {
  const entryPointsFormatted = logger.list(userEntrypoints, { dim: true });
  const isMultiple = userEntrypoints.length > 1;
  return `${pc2.red(pc2.bold(`Entry ${isMultiple ? "points do not exist" : "point does not exist"}`))}

${entryPointsFormatted}

Please check that ${isMultiple ? "these paths exist and point" : "this path exists and points"} to ${isMultiple ? "valid files" : "a valid file"}.`;
};
function formatBunBuildError(error) {
  const pos = error.position;
  if (!pos) {
    return error.message;
  }
  const lineNum = String(pos.line);
  const padding = " ".repeat(lineNum.length);
  const caretPos = pos.column;
  return `${pc2.dim(`${lineNum} |`)} ${logger.highlight(pos.lineText)}
${pc2.dim(`${padding} |`)} ${" ".repeat(caretPos)}${pc2.red("^")}

${pc2.bold(error.message)}
    ${pc2.dim("at")} ${pc2.cyan(getShortFilePath(pos.file))}${pc2.dim(":")}${pc2.yellow(lineNum)}${pc2.dim(":")}${pc2.yellow(String(pos.column))}`;
}
var handleErrorAndExit = (error, context) => {
  handleError(error, context);
  process.exit(1);
};

// packages/bunup/src/plugins/exports.ts
import path2 from "path";
import pc3 from "picocolors";

// packages/bunup/src/constants/re.ts
var JS_RE = /\.(js|jsx|cjs|mjs)$/;
var TS_RE = /\.(ts|tsx|mts|cts)$/;
var DTS_RE = /\.(d\.(ts|mts|cts))$/;
var JS_TS_RE = new RegExp(`${JS_RE.source}|${TS_RE.source}`);
var JS_DTS_RE = new RegExp(`${JS_RE.source}|${DTS_RE.source}`);
var CSS_RE = /\.(css)$/;

// packages/bunup/src/utils/file.ts
import fs from "fs/promises";
import path from "path";
async function cleanOutDir(rootDir, outDir) {
  const normalizedOutDir = path.normalize(outDir);
  if (["/", ".", "..", "~"].includes(normalizedOutDir) || normalizedOutDir.startsWith("/") || normalizedOutDir.startsWith("~")) {
    throw new BunupBuildError(`Invalid output directory: "${outDir}" is not allowed`);
  }
  const outDirPath = path.join(rootDir, outDir);
  if (!path.normalize(outDirPath).startsWith(path.normalize(rootDir))) {
    throw new BunupBuildError(`Output directory "${outDir}" escapes root directory`);
  }
  try {
    await fs.rm(outDirPath, { recursive: true, force: true });
    await fs.mkdir(outDirPath, { recursive: true });
  } catch (error) {
    throw new BunupBuildError(`Failed to manage output directory: ${error}`);
  }
}
function getFilesFromGlobs(patterns, cwd) {
  const includePatterns = patterns.filter((p) => !p.startsWith("!"));
  const excludePatterns = patterns.filter((p) => p.startsWith("!")).map((p) => p.slice(1));
  const includedFiles = new Set;
  for (const pattern of includePatterns) {
    const glob = new Bun.Glob(pattern);
    for (const file of glob.scanSync(cwd)) {
      includedFiles.add(file);
    }
  }
  if (excludePatterns.length > 0) {
    for (const pattern of excludePatterns) {
      const glob = new Bun.Glob(pattern);
      for (const file of glob.scanSync(cwd)) {
        includedFiles.delete(file);
      }
    }
  }
  return Array.from(includedFiles);
}
function isTypeScriptFile(path2) {
  if (!path2)
    return false;
  return TS_RE.test(path2);
}
function isJavascriptFile(path2) {
  if (!path2)
    return false;
  return JS_RE.test(path2);
}
function isGlobPattern(pattern) {
  return /[*?[\]{}]/.test(pattern);
}
async function detectFileFormatting(filePath) {
  try {
    const content = await Bun.file(filePath).text();
    const hasTrailingNewline = content.endsWith(`
`);
    const lines = content.split(`
`);
    for (const line of lines) {
      const match = line.match(/^(\s+)/);
      if (match) {
        const indent = match[1];
        if (indent?.startsWith("\t")) {
          return { indentation: "\t", hasTrailingNewline };
        }
        return { indentation: indent ?? "  ", hasTrailingNewline };
      }
    }
    return { indentation: "  ", hasTrailingNewline };
  } catch {
    return { indentation: "  ", hasTrailingNewline: true };
  }
}

// packages/bunup/src/plugins/exports.ts
function exports(options = {}) {
  return {
    name: "exports",
    hooks: {
      onBuildDone: async (ctx) => {
        await processPackageJsonExports(ctx, options);
      }
    }
  };
}
async function processPackageJsonExports(ctx, options) {
  const { files, options: buildOptions, meta } = ctx;
  if (!meta.packageJson.path || !meta.packageJson.data) {
    return;
  }
  try {
    const { exportsField, entryPoints } = generateExportsFields(files, options.exclude, options.excludeCli, options.excludeCss, ctx);
    const updatedFiles = createUpdatedFilesArray(meta.packageJson.data, buildOptions.outDir);
    const mergedExports = mergeCustomExportsWithGenerated(exportsField, options.customExports, ctx);
    const finalExports = addPackageJsonOrWildcardExport(mergedExports, options.includePackageJson, options.all);
    const newPackageJson = createUpdatedPackageJson(meta.packageJson.data, entryPoints, finalExports, updatedFiles);
    await validateBinFields(meta.packageJson.data, buildOptions.name, meta.packageJson.path, meta.rootDir);
    if (Bun.deepEquals(newPackageJson, meta.packageJson.data)) {
      return;
    }
    const formatting = await detectFileFormatting(meta.packageJson.path);
    let jsonContent = JSON.stringify(newPackageJson, null, formatting.indentation);
    if (formatting.hasTrailingNewline) {
      jsonContent += `
`;
    }
    await Bun.write(meta.packageJson.path, jsonContent);
  } catch {
    logger.error("Failed to update package.json");
  }
}
function generateExportsFields(files, exclude, excludeCli, excludeCss, ctx) {
  const filteredFiles = filterFiles(files, excludeCli);
  const { filesByExportKey, allDtsFiles, cssFiles } = groupFilesByExportKey(filteredFiles);
  const exportsField = createExportEntries(filesByExportKey);
  if (!excludeCss) {
    addCssToExports(exportsField, cssFiles);
  }
  const filteredExportsField = filterExportKeys(exportsField, exclude, ctx);
  const filteredAllDtsFiles = filterDtsFiles(allDtsFiles, exclude, ctx);
  const entryPoints = extractEntryPoints(filteredExportsField, filteredAllDtsFiles);
  return { exportsField: filteredExportsField, entryPoints };
}
function groupFilesByExportKey(files) {
  const filesByExportKey = new Map;
  const allDtsFiles = new Map;
  const cssFiles = [];
  for (const file of files) {
    const exportKey = getExportKey(cleanPath(file.pathRelativeToOutdir));
    if (CSS_RE.test(file.fullPath)) {
      cssFiles.push(file);
      continue;
    }
    const format = file.format === "esm" ? "import" : "require";
    if (!filesByExportKey.has(exportKey)) {
      filesByExportKey.set(exportKey, new Map);
      allDtsFiles.set(exportKey, []);
    }
    const formatMap = filesByExportKey.get(exportKey);
    const dtsFiles = allDtsFiles.get(exportKey);
    if (formatMap && dtsFiles) {
      if (!formatMap.has(format)) {
        formatMap.set(format, { dts: undefined, source: undefined });
      }
      const fileEntry = formatMap.get(format);
      if (fileEntry) {
        if (file.dts) {
          fileEntry.dts = file;
          dtsFiles.push(file);
        } else {
          fileEntry.source = file;
        }
      }
    }
  }
  return { filesByExportKey, allDtsFiles, cssFiles };
}
function createExportEntries(filesByExportKey) {
  const exportsField = {};
  for (const [exportKey, formatMap] of filesByExportKey.entries()) {
    exportsField[exportKey] = {};
    let hasFormatSpecificTypes = false;
    let primaryTypesPath;
    for (const [format, files] of formatMap.entries()) {
      const formatKey = format;
      if (files.dts && files.source) {
        exportsField[exportKey][formatKey] = {
          types: `./${cleanPath(files.dts.pathRelativeToRootDir)}`,
          default: `./${cleanPath(files.source.pathRelativeToRootDir)}`
        };
        hasFormatSpecificTypes = true;
        if (!primaryTypesPath) {
          primaryTypesPath = `./${cleanPath(files.dts.pathRelativeToRootDir)}`;
        }
      } else if (files.source) {
        exportsField[exportKey][formatKey] = `./${cleanPath(files.source.pathRelativeToRootDir)}`;
        if (files.dts) {
          primaryTypesPath = `./${cleanPath(files.dts.pathRelativeToRootDir)}`;
        }
      } else if (files.dts) {
        primaryTypesPath = `./${cleanPath(files.dts.pathRelativeToRootDir)}`;
      }
    }
    if (!hasFormatSpecificTypes && primaryTypesPath) {
      exportsField[exportKey].types = primaryTypesPath;
    }
  }
  return exportsField;
}
function extractEntryPoints(exportsField, allDtsFiles) {
  const entryPoints = {};
  const dotExport = exportsField["."];
  if (!dotExport || typeof dotExport === "string") {
    return entryPoints;
  }
  for (const [field, value] of Object.entries(dotExport)) {
    if (field === "types")
      continue;
    const entryPoint = exportFieldToEntryPoint(field);
    if (typeof value === "string") {
      entryPoints[entryPoint] = value;
    } else if (value && typeof value === "object" && "default" in value) {
      entryPoints[entryPoint] = value.default;
    }
  }
  const dotEntryDtsFiles = allDtsFiles.get(".");
  if (dotEntryDtsFiles?.length) {
    const standardDts = findStandardDtsFile(dotEntryDtsFiles);
    if (standardDts) {
      entryPoints.types = `./${cleanPath(standardDts.pathRelativeToRootDir)}`;
    } else {
      entryPoints.types = extractTypesFromExport(dotExport);
    }
  }
  return entryPoints;
}
function findStandardDtsFile(dtsFiles) {
  return dtsFiles.find((file) => file.pathRelativeToRootDir.endsWith(".d.ts") && !file.pathRelativeToRootDir.endsWith(".d.mts") && !file.pathRelativeToRootDir.endsWith(".d.cts"));
}
function extractTypesFromExport(dotExport) {
  const typesValue = dotExport.types;
  if (typeof typesValue === "string") {
    return typesValue;
  }
  if (typesValue && typeof typesValue === "object" && "types" in typesValue) {
    return typesValue.types;
  }
  const importValue = dotExport.import;
  if (importValue && typeof importValue === "object" && "types" in importValue) {
    return importValue.types;
  }
  return;
}
function createUpdatedFilesArray(packageJsonData, outDir) {
  const existingFiles = Array.isArray(packageJsonData.files) ? packageJsonData.files : [];
  return [...new Set([...existingFiles, outDir])];
}
function mergeCustomExportsWithGenerated(baseExports, customExportsProvider, ctx) {
  const mergedExports = { ...baseExports };
  if (!customExportsProvider) {
    return mergedExports;
  }
  const customExports = customExportsProvider({
    options: ctx.options,
    meta: ctx.meta
  });
  if (!customExports) {
    return mergedExports;
  }
  for (const [key, value] of Object.entries(customExports)) {
    if (typeof value === "string") {
      mergedExports[key] = value;
    } else {
      const existingExport = mergedExports[key];
      if (typeof existingExport === "object" && existingExport !== null) {
        mergedExports[key] = { ...existingExport, ...value };
      } else {
        mergedExports[key] = value;
      }
    }
  }
  return mergedExports;
}
function createUpdatedPackageJson(originalData, entryPoints, exports2, files) {
  const { main, module, types, ...restPackageJson } = originalData;
  const newPackageJson = {
    ...Object.fromEntries(Object.entries({
      name: originalData.name,
      description: originalData.description,
      version: originalData.version,
      type: originalData.type,
      private: originalData.private
    }).filter(([_, value]) => value !== undefined)),
    files,
    ...entryPoints,
    exports: exports2
  };
  for (const key in restPackageJson) {
    if (Object.hasOwn(restPackageJson, key) && !Object.hasOwn(newPackageJson, key)) {
      newPackageJson[key] = restPackageJson[key];
    }
  }
  return newPackageJson;
}
function filterFiles(files, excludeCli) {
  return files.filter((file) => (JS_DTS_RE.test(file.fullPath) || CSS_RE.test(file.fullPath)) && (file.kind === "entry-point" || file.kind === "asset") && (file.format === "esm" || file.format === "cjs" || CSS_RE.test(file.fullPath)) && (!file.entrypoint || !isCliEntrypoint(file.entrypoint, excludeCli)));
}
var CLI_EXCLUSION_PATTERNS = [
  "**/cli.{ts,tsx,js,jsx,mjs,cjs}",
  "**/cli/index.{ts,tsx,js,jsx,mjs,cjs}",
  "**/bin.{ts,tsx,js,jsx,mjs,cjs}",
  "**/bin/index.{ts,tsx,js,jsx,mjs,cjs}"
];
function isCliEntrypoint(entrypoint, excludeCli) {
  const cliPatterns = excludeCli !== false ? CLI_EXCLUSION_PATTERNS : [];
  return cliPatterns.some((pattern) => new Bun.Glob(pattern).match(entrypoint));
}
function filterExportKeys(exportsField, exclude, ctx) {
  if (!exclude) {
    return exportsField;
  }
  const userPatterns = typeof exclude === "function" ? exclude({ options: ctx.options, meta: ctx.meta }) : exclude;
  if (!userPatterns || userPatterns.length === 0) {
    return exportsField;
  }
  const filteredExports = {};
  for (const [exportKey, value] of Object.entries(exportsField)) {
    const shouldExclude = userPatterns.some((pattern) => new Bun.Glob(pattern).match(exportKey));
    if (!shouldExclude) {
      filteredExports[exportKey] = value;
    }
  }
  return filteredExports;
}
function filterDtsFiles(allDtsFiles, exclude, ctx) {
  if (!exclude) {
    return allDtsFiles;
  }
  const userPatterns = typeof exclude === "function" ? exclude({ options: ctx.options, meta: ctx.meta }) : exclude;
  if (!userPatterns || userPatterns.length === 0) {
    return allDtsFiles;
  }
  const filteredDtsFiles = new Map;
  for (const [exportKey, files] of allDtsFiles.entries()) {
    const shouldExclude = userPatterns.some((pattern) => new Bun.Glob(pattern).match(exportKey));
    if (!shouldExclude) {
      filteredDtsFiles.set(exportKey, files);
    }
  }
  return filteredDtsFiles;
}
function getExportKey(pathRelativeToOutdir) {
  const pathSegments = cleanPath(removeExtension(pathRelativeToOutdir)).split("/");
  if (pathSegments.length === 1 && (pathSegments[0]?.startsWith("index") || pathSegments[0]?.startsWith("main"))) {
    return ".";
  }
  return `./${pathSegments.filter((segment) => !segment.startsWith("index") && !segment.startsWith("main")).join("/")}`;
}
function removeExtension(filePath) {
  const basename = path2.basename(filePath);
  const firstDotIndex = basename.indexOf(".");
  if (firstDotIndex === -1) {
    return filePath;
  }
  const nameWithoutExtensions = basename.slice(0, firstDotIndex);
  const directory = path2.dirname(filePath);
  return directory === "." ? nameWithoutExtensions : path2.join(directory, nameWithoutExtensions);
}
function addCssToExports(exportsField, cssFiles) {
  if (cssFiles.length === 0)
    return;
  for (const cssFile of cssFiles) {
    const exportKey = getCssExportKey(cleanPath(cssFile.pathRelativeToOutdir));
    exportsField[exportKey] = `./${cleanPath(cssFile.pathRelativeToRootDir)}`;
  }
}
function getCssExportKey(pathRelativeToOutdir) {
  const pathSegments = cleanPath(removeExtension(pathRelativeToOutdir)).split("/");
  const fileName = pathSegments[pathSegments.length - 1];
  if (fileName === "index") {
    if (pathSegments.length === 1) {
      return "./styles.css";
    } else {
      return `./${pathSegments.slice(0, -1).join("/")}.css`;
    }
  } else {
    return `./${pathSegments.join("/")}.css`;
  }
}
function addPackageJsonOrWildcardExport(exports2, includePackageJson, all) {
  const finalExports = { ...exports2 };
  if (all) {
    finalExports["./*"] = "./*";
  } else if (includePackageJson !== false) {
    if (!finalExports["./package.json"]) {
      finalExports["./package.json"] = "./package.json";
    }
  }
  return finalExports;
}
function exportFieldToEntryPoint(exportField) {
  switch (exportField) {
    case "types":
      return "types";
    case "require":
      return "main";
    default:
      return "module";
  }
}
async function validateBinFields(packageJsonData, projectName, packageJsonPath, rootDir) {
  if (!packageJsonData?.bin || !rootDir)
    return;
  const bin = packageJsonData.bin;
  const invalidBins = [];
  if (typeof bin === "string") {
    const fullPath = path2.resolve(rootDir, bin);
    const exists = await Bun.file(fullPath).exists();
    if (!exists) {
      invalidBins.push(`bin field points to ${pc3.yellow(bin)}`);
    }
  } else if (typeof bin === "object" && bin !== null) {
    for (const [name, binPath] of Object.entries(bin)) {
      if (typeof binPath === "string") {
        const fullPath = path2.resolve(rootDir, binPath);
        const exists = await Bun.file(fullPath).exists();
        if (!exists) {
          invalidBins.push(`${pc3.yellow(pc3.bold(name))} points to ${pc3.red(binPath)}`);
        }
      }
    }
  }
  if (invalidBins.length === 0)
    return;
  const project = projectName ? ` ${projectName}` : "";
  const count = invalidBins.length;
  const depText = count === 1 ? "binary" : "binaries";
  const verb = count === 1 ? "points" : "point";
  const fileText = count === 1 ? "file" : "files";
  const pathPrefix = packageJsonPath ? pc3.cyan(getShortFilePath(packageJsonPath)) : "";
  const message = `
Your project${project} has ${count} ${depText} in the bin field that ${verb} to invalid ${fileText}:

  ${pathPrefix}:
    ${invalidBins.join(`
    `)}`;
  logger.log(message, { leftPadding: true });
}

// packages/bunup/src/plugins/inject-styles.ts
import path3 from "path";
import { getDefaultCssBrowserTargets } from "@bunup/shared";
import { transform } from "lightningcss";
function injectStyles(options) {
  const { inject, minify = true } = options ?? {};
  return {
    name: "bunup:inject-styles",
    async setup(build) {
      build.onResolve({ filter: /^__inject-style$/ }, () => {
        return {
          path: "__inject-style",
          namespace: "__inject-style"
        };
      });
      build.onLoad({ filter: /^__inject-style$/, namespace: "__inject-style" }, () => {
        return {
          contents: `
                      export default function injectStyle(css) {
                        if (!css || typeof document === 'undefined') return

                        const head = document.head || document.getElementsByTagName('head')[0]
                        const style = document.createElement('style')
                        head.appendChild(style)

                        if (style.styleSheet) {
                          style.styleSheet.cssText = css
                        } else {
                          style.appendChild(document.createTextNode(css))
                        }
                      }
                      `,
          loader: "js"
        };
      });
      build.onLoad({ filter: CSS_RE }, async (args) => {
        const source = await Bun.file(args.path).text();
        const { code, warnings } = transform({
          filename: path3.basename(args.path),
          code: Buffer.from(source),
          minify,
          targets: getDefaultCssBrowserTargets()
        });
        for (const warning of warnings) {
          logger.warn(warning.message);
        }
        const stringifiedCode = JSON.stringify(code.toString());
        const js = inject ? await inject(stringifiedCode, args.path) : `import injectStyle from '__inject-style';injectStyle(${stringifiedCode})`;
        return {
          contents: js,
          loader: "js"
        };
      });
    }
  };
}

// packages/bunup/src/plugins/shims.ts
function shims() {
  return {
    name: "bunup:shims",
    setup(build) {
      const isNodeCompatibleTarget = build.config.target === "node" || build.config.target === "bun";
      const isEsm = build.config.format === "esm";
      const isCjs = build.config.format === "cjs";
      if (!isNodeCompatibleTarget || !isEsm && !isCjs) {
        return;
      }
      build.config.define = {
        ...build.config.define,
        ...isCjs && {
          "import.meta.url": "importMetaUrl"
        }
      };
      build.onLoad({ filter: JS_TS_RE }, async ({ path: path4 }) => {
        const content = await Bun.file(path4).text();
        let shimCode = "";
        if (isEsm && (/\b__dirname\b/.test(content) || /\b__filename\b/.test(content))) {
          shimCode = `import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

`;
        }
        if (isCjs && /\bimport\.meta\.url\b/.test(content)) {
          shimCode = `import { pathToFileURL } from 'url';

const importMetaUrl = pathToFileURL(__filename).href;

`;
        }
        if (!shimCode)
          return;
        const lines = content.split(`
`);
        const firstLine = lines[0];
        const restLines = lines.slice(1);
        return {
          contents: [firstLine, shimCode, ...restLines].join(`
`)
        };
      });
    }
  };
}

// packages/bunup/src/plugins/unused.ts
import pc4 from "picocolors";
function unused(options = {}) {
  const { level = "warn", ignore = [] } = options;
  return {
    name: "unused",
    hooks: {
      onBuildDone: async (ctx) => {
        const { options: buildOptions, meta, files } = ctx;
        if (buildOptions.watch || buildOptions.compile)
          return;
        const usedDeps = await collectUsedDependencies(files, buildOptions);
        const pkgDeps = extractPackageDependencies(meta.packageJson.data?.dependencies);
        const unusedDeps = findUnusedDependencies(pkgDeps, usedDeps, ignore);
        const misplacedTypes = findMisplacedTypes(pkgDeps, usedDeps, ignore);
        reportIssues(unusedDeps, misplacedTypes, buildOptions.name, level);
      }
    }
  };
}
async function collectUsedDependencies(files, buildOptions) {
  const transpiler = new Bun.Transpiler({ loader: "ts" });
  const externals = [
    ...buildOptions.external ?? [],
    ...buildOptions.noExternal ?? []
  ];
  const usedDeps = new Set;
  const jsFiles = files.filter((f) => isJavascriptFile(f.fullPath) || isTypeScriptFile(f.fullPath));
  for (const file of jsFiles) {
    const code = (await Bun.file(file.fullPath).text()).replace(/^#!.*$/m, "");
    const imports = transpiler.scanImports(code).map((imp) => imp.path);
    for (const path4 of imports) {
      if (isExternal(path4, externals) || isBuiltin(path4))
        continue;
      usedDeps.add(path4);
    }
  }
  return usedDeps;
}
function isExternal(path4, externals) {
  return externals.some((ex) => typeof ex === "string" ? path4.startsWith(ex) : ex.test(path4));
}
function isBuiltin(path4) {
  return path4.startsWith("node:") || path4.startsWith("bun:");
}
function extractPackageDependencies(deps) {
  return typeof deps === "object" ? Object.keys(deps) : [];
}
function findUnusedDependencies(allDeps, usedDeps, ignore) {
  return allDeps.filter((dep) => {
    if (ignore.includes(dep))
      return false;
    return !Array.from(usedDeps).some((used) => used === dep || used.startsWith(`${dep}/`));
  });
}
function findMisplacedTypes(allDeps, usedDeps, ignore) {
  return allDeps.filter((dep) => {
    if (!dep.startsWith("@types/"))
      return false;
    if (ignore.includes(dep))
      return false;
    return !Array.from(usedDeps).some((used) => used === dep || used.startsWith(`${dep}/`));
  });
}
function reportIssues(unused2, misplaced, projectName, level) {
  reportIssue(unused2, "unused", projectName, level);
  reportIssue(misplaced, "misplaced-types", projectName, level);
}
function reportIssue(deps, type, projectName, level) {
  if (deps.length === 0)
    return;
  const count = deps.length;
  const coloredDeps = formatListWithAnd(deps.map((d) => pc4.yellow(d)));
  const project = projectName ? ` ${projectName}` : "";
  const message = buildMessage(type, count, coloredDeps, project, deps);
  if (level === "error") {
    logger.log(pc4.red(message), { leftPadding: true });
    process.exit(1);
  } else {
    logger.log(message, { leftPadding: true });
  }
}
function buildMessage(type, count, coloredDeps, project, deps) {
  const plural = count === 1 ? "it" : "them";
  if (type === "unused") {
    const depText2 = count === 1 ? "dependency" : "dependencies";
    const cmd2 = pc4.cyan(`bun remove ${deps.join(" ")}`);
    return `
Your project${project} has ${count} unused ${depText2}: ${coloredDeps}. You can remove ${plural} with ${cmd2}`;
  }
  const depText = count === 1 ? "package" : "packages";
  const cmd = pc4.cyan(`bun remove ${deps.join(" ")} && bun add --dev ${deps.join(" ")}`);
  return `
Your project${project} has ${count} type ${depText} that should be in devDependencies: ${coloredDeps}. Move ${plural} to devDependencies with ${cmd}`;
}

// packages/bunup/src/utils/common.ts
function ensureArray(value) {
  return Array.isArray(value) ? value : [value].filter(Boolean);
}
function ensureObject(value) {
  return typeof value === "object" && value !== null ? value : {};
}

export { __toESM, __require, logTime, logger, formatFileSize, formatListWithAnd, getShortFilePath, cleanPath, BunupBuildError, BunupDTSBuildError, BunupCLIError, BunupWatchError, BunupVersionError, parseErrorMessage, handleError, formatNoEntryPointsFoundError, formatInvalidEntryPointsError, formatBunBuildError, handleErrorAndExit, cleanOutDir, getFilesFromGlobs, isTypeScriptFile, isJavascriptFile, isGlobPattern, exports, injectStyles, shims, unused, ensureArray, ensureObject };
