// @bun
import {
  BunupBuildError,
  BunupDTSBuildError,
  BunupVersionError,
  cleanOutDir,
  cleanPath,
  ensureArray,
  ensureObject,
  exports,
  formatBunBuildError,
  formatInvalidEntryPointsError,
  formatListWithAnd,
  formatNoEntryPointsFoundError,
  getFilesFromGlobs,
  getShortFilePath,
  injectStyles,
  isJavascriptFile,
  logger,
  parseErrorMessage,
  shims,
  unused
} from "./bunup-qb65sm3k.js";

// packages/bunup/src/loaders.ts
import path from "path";
import { loadConfig } from "coffi";
async function processLoadedConfigs(config, cwd, filter) {
  return Array.isArray(config) && config[0] && "root" in config[0] ? config.filter((c) => filter ? filter.includes(c.name) : true).map((c) => ({
    rootDir: path.resolve(cwd, c.root),
    options: setOrSuffixField(c.config ?? {}, "name", c.name)
  })) : [
    {
      rootDir: cwd,
      options: filterConfigArrayByName(config, filter)
    }
  ];
}
function filterConfigArrayByName(config, filter) {
  if (Array.isArray(config) && filter) {
    return config.filter((c) => c.name ? filter.includes(c.name) : true);
  }
  return config;
}
function setOrSuffixField(objectOrArray, field, prefix) {
  const addPrefix = (obj) => {
    const existingValue = obj[field];
    const newValue = existingValue ? `${prefix}-${existingValue}` : prefix;
    return { ...obj, [field]: newValue };
  };
  return Array.isArray(objectOrArray) ? objectOrArray.map(addPrefix) : addPrefix(objectOrArray);
}
async function loadPackageJson(cwd = process.cwd()) {
  const { config, filepath } = await loadConfig({
    name: "package",
    cwd,
    extensions: [".json"]
  });
  return {
    data: config,
    path: filepath
  };
}

// packages/bunup/src/build.ts
import path3 from "path";
import { generateDts, logIsolatedDeclarationErrors } from "@bunup/dts";

// packages/bunup/src/ensure-bun-version.ts
import pc from "picocolors";
var MINIMUM_BUN_VERSION = "1.0.11";
function ensureBunVersion(requiredVersion, feature) {
  const currentVersion = Bun.version;
  const satisfiesRequirement = Bun.semver.satisfies(currentVersion, `>=${requiredVersion}`);
  if (!satisfiesRequirement) {
    throw new BunupVersionError(pc.white(`Bun version ${pc.cyan(requiredVersion)} or higher is required${feature ? ` for ${feature}` : ""}. You have ${pc.yellow(currentVersion)} installed. Run ${pc.green("bun upgrade")} to update.`));
  }
}
function ensureMinimumBunVersion() {
  ensureBunVersion(MINIMUM_BUN_VERSION);
}

// packages/bunup/src/helpers/on-success.ts
import { exec } from "tinyexec";
import treeKill from "tree-kill";
async function executeOnSuccess(onSuccess, options, signal) {
  if (typeof onSuccess === "function") {
    const result = await onSuccess(options);
    if (typeof result === "function") {
      signal.addEventListener("abort", () => {
        result();
      });
    }
  } else {
    const command = typeof onSuccess === "string" ? onSuccess : onSuccess.cmd;
    const spawnOptions = typeof onSuccess === "object" && "options" in onSuccess ? onSuccess.options : {};
    logger.info(`Running command: ${command}`, {
      muted: true
    });
    const proc = exec(command, [], {
      timeout: spawnOptions?.timeout,
      nodeOptions: {
        shell: true,
        stdio: "inherit",
        env: spawnOptions?.env,
        cwd: spawnOptions?.cwd
      }
    });
    proc.then(({ exitCode }) => {
      if (exitCode) {
        process.exitCode = exitCode;
      }
    });
    signal.addEventListener("abort", () => {
      if (typeof proc.pid === "number") {
        treeKill(proc.pid, spawnOptions?.killSignal ?? "SIGTERM");
      }
    });
  }
}

// packages/bunup/src/options.ts
import path2 from "path";

// packages/bunup/src/plugins/css-typed-modules.ts
import { transform } from "lightningcss";
function cssTypedModulesPlugin() {
  return {
    name: "bunup:css-typed-modules",
    setup(build) {
      build.onLoad({ filter: /\.module\.css$/ }, async (args) => {
        const uc = new Set;
        const source = await Bun.file(args.path).text();
        transform({
          filename: args.path,
          code: Buffer.from(source),
          visitor: {
            Rule: {
              style(rule) {
                rule.value.selectors.forEach((selector) => {
                  selector.forEach((component) => {
                    if (component.type === "class") {
                      uc.add(component.name);
                    }
                  });
                });
              }
            }
          }
        });
        const classes = Array.from(uc);
        const destination = `${args.path}.d.ts`;
        const dts = `// This file is automatically generated. Do not edit.
declare const classes: {
${classes.map((className) => `  readonly "${className}": string;`).join(`
`)}
};
export default classes;
`;
        await Bun.write(destination, dts);
      });
    }
  };
}

// packages/bunup/src/utils/package.ts
function getPackageDeps(packageJson) {
  if (!packageJson)
    return [];
  return Array.from(new Set([
    ...Object.keys(packageJson.dependencies || {}),
    ...Object.keys(packageJson.peerDependencies || {})
  ]));
}

// packages/bunup/src/helpers/external.ts
function getPackageDepsPatterns(packageJson) {
  return getPackageDeps(packageJson).map((dep) => new RegExp(`^${dep}($|\\/|\\\\)`));
}
function matchesPattern(path2, pattern) {
  return typeof pattern === "string" ? pattern === path2 : pattern.test(path2);
}
function isExternalFromPackageJson(path2, options, packageJson) {
  const packageDepsPatterns = getPackageDepsPatterns(packageJson);
  if (options.packages === "bundle") {
    const explicitlyExternal = options.external?.some((pattern) => matchesPattern(path2, pattern));
    return explicitlyExternal;
  }
  if (options.packages === "external") {
    const explicitlyBundled = options.noExternal?.some((pattern) => matchesPattern(path2, pattern));
    if (explicitlyBundled) {
      return false;
    }
    return packageDepsPatterns.some((pattern) => pattern.test(path2));
  }
  const matchesExternalPattern = packageDepsPatterns.some((pattern) => pattern.test(path2)) || options.external?.some((pattern) => matchesPattern(path2, pattern));
  const isExcludedFromExternal = options.noExternal?.some((pattern) => matchesPattern(path2, pattern));
  return matchesExternalPattern && !isExcludedFromExternal;
}

// packages/bunup/src/plugins/internal/external-option.ts
function externalOptionPlugin(options, packageJson) {
  return {
    name: "bunup:external-option",
    setup(build) {
      build.onResolve({ filter: /.*/ }, (args) => {
        const importPath = args.path;
        if (importPath.startsWith("node:") || importPath.startsWith("bun:") || isExternalFromPackageJson(importPath, options, packageJson)) {
          return {
            path: importPath,
            external: true
          };
        }
        return null;
      });
    }
  };
}

// packages/bunup/src/plugins/internal/use-client.ts
function useClient() {
  return {
    name: "use-client",
    hooks: {
      onBuildDone: async ({ files }) => {
        const filteredFiles = files.filter((file) => isJavascriptFile(file.fullPath));
        for (const file of filteredFiles) {
          let text = await Bun.file(file.fullPath).text();
          const hasUseClient = text.split(`
`).some((line) => line.trim().startsWith(`"use client";`));
          if (hasUseClient) {
            text = text.replaceAll(`"use client";`, "");
            text = `"use client";
${text}`;
          }
          await Bun.write(file.fullPath, text);
        }
      }
    }
  };
}

// packages/bunup/src/options.ts
var DEFAULT_ENTYPOINTS = [
  "index.ts",
  "index.tsx",
  "src/index.ts",
  "src/index.tsx",
  "cli.ts",
  "src/cli.ts",
  "src/cli/index.ts"
];
var DEFAULT_OUT_DIR = "dist";
var DEFAULT_EXECUTABLE_OUT_DIR = "bin";
var DEFAULT_OPTIONS = {
  entry: DEFAULT_ENTYPOINTS,
  format: "esm",
  target: "node",
  dts: true,
  clean: true
};
function resolveBuildOptions(userOptions) {
  const options = {
    ...DEFAULT_OPTIONS,
    outDir: userOptions.compile ? DEFAULT_EXECUTABLE_OUT_DIR : DEFAULT_OUT_DIR,
    ...userOptions
  };
  if (options.jsx) {
    ensureBunVersion("1.2.23", "jsx option");
  }
  if (options.compile) {
    ensureBunVersion("1.3.0", "compile option");
  }
  return options;
}
function resolvePlugins(options, packageJsonData) {
  const plugins = [];
  if (options.plugins) {
    plugins.push(...options.plugins);
  }
  if (options.css?.typedModules !== false) {
    plugins.push(cssTypedModulesPlugin());
  }
  if (options.css?.inject) {
    plugins.push(injectStyles(ensureObject(options.css.inject)));
  }
  if (options.shims) {
    plugins.push(shims());
  }
  if (options.exports) {
    plugins.push(exports(ensureObject(options.exports)));
  }
  if (options.unused) {
    plugins.push(unused(ensureObject(options.unused)));
  }
  plugins.push(useClient());
  plugins.push(externalOptionPlugin(options, packageJsonData));
  return plugins;
}
function getResolvedMinify(options) {
  const { minify, minifyWhitespace, minifyIdentifiers, minifySyntax } = options;
  const defaultValue = minify === true;
  return {
    whitespace: minifyWhitespace ?? defaultValue,
    identifiers: minifyIdentifiers ?? defaultValue,
    syntax: minifySyntax ?? defaultValue
  };
}
function getResolvedTarget(target) {
  return target ?? "node";
}
function getResolvedSourcemap(sourcemap) {
  if (sourcemap === true) {
    return "inline";
  }
  return typeof sourcemap === "string" ? sourcemap : undefined;
}
function getResolvedDefine(define, env) {
  return {
    ...typeof env === "object" && Object.keys(env).reduce((acc, key) => {
      const value = JSON.stringify(env[key]);
      acc[`process.env.${key}`] = value;
      acc[`import.meta.env.${key}`] = value;
      return acc;
    }, {}),
    ...define
  };
}
function getDefaultChunkNaming(name) {
  return `shared/${name ?? "chunk"}-[hash].[ext]`;
}
function getCompileNaming(entry, compile, format) {
  let resolvedEntry;
  const compileObj = typeof compile === "object" ? compile : {};
  const target = typeof compile === "string" ? compile : compileObj.target;
  if (entry.length > 1) {
    throw new BunupBuildError("Can only compile one entrypoint at a time. If you want to compile multiple entries, use build config array. Check https://bunup.dev/docs/advanced/compile#multiple-entrypoints for more information.");
  } else {
    resolvedEntry = entry[0];
  }
  const { name: entryName } = path2.parse(resolvedEntry);
  const parentDirName = path2.basename(path2.dirname(resolvedEntry));
  const execName = compileObj.outfile ?? (entryName === "index" && parentDirName !== "src" ? parentDirName : entryName);
  const name = [execName];
  if (format !== "esm") {
    name.push(`-${format}`);
  }
  if (target) {
    name.push(`-${target.replace("bun-", "")}`);
  }
  return `[dir]/${name.join("")}-[hash].[ext]`;
}
function getResolvedSplitting(splitting, format) {
  return splitting === undefined ? format === "esm" : splitting;
}
function getResolvedDtsSplitting(_buildSplitting, dtsSplitting) {
  return !!dtsSplitting;
}
function getResolvedEnv(env) {
  return typeof env === "string" ? env : undefined;
}

// packages/bunup/src/plugins/utils.ts
function filterBunPlugins(plugins) {
  if (!plugins)
    return [];
  return plugins.filter((p) => ("setup" in p));
}
function filterBunupPlugins(plugins) {
  if (!plugins)
    return [];
  return plugins.filter((p) => ("hooks" in p));
}
async function runPluginBuildStartHooks(bunupPlugins, ctx) {
  if (!bunupPlugins)
    return;
  for (const plugin of bunupPlugins) {
    if (plugin.hooks.onBuildStart) {
      await plugin.hooks.onBuildStart(ctx);
    }
  }
}
async function runPluginBuildDoneHooks(bunupPlugins, ctx) {
  if (!bunupPlugins)
    return;
  for (const plugin of bunupPlugins) {
    if (plugin.hooks.onBuildDone) {
      await plugin.hooks.onBuildDone(ctx);
    }
  }
}

// packages/bunup/src/utils/extension.ts
function getDefaultJsOutputExtension(format, packageType) {
  switch (format) {
    case "esm":
      return isModulePackage(packageType) ? ".js" : ".mjs";
    case "cjs":
      return isModulePackage(packageType) ? ".cjs" : ".js";
    case "iife":
      return ".global.js";
  }
}
function getDefaultDtsOutputExtention(format, packageType, kind) {
  if (kind === "chunk")
    return ".d.ts";
  switch (format) {
    case "esm":
      return isModulePackage(packageType) ? ".d.ts" : ".d.mts";
    case "cjs":
      return isModulePackage(packageType) ? ".d.cts" : ".d.ts";
    case "iife":
      return ".global.d.ts";
  }
}
function isModulePackage(packageType) {
  return packageType === "module";
}
function replaceExtension(filePath, newExtension) {
  if (!filePath) {
    return filePath;
  }
  const normalizedExtension = newExtension.startsWith(".") ? newExtension : `.${newExtension}`;
  const lastSlashIndex = Math.max(filePath.lastIndexOf("/"), filePath.lastIndexOf("\\"));
  const directory = lastSlashIndex >= 0 ? filePath.substring(0, lastSlashIndex + 1) : "";
  const filename = lastSlashIndex >= 0 ? filePath.substring(lastSlashIndex + 1) : filePath;
  const lastDotIndex = filename.lastIndexOf(".");
  if (lastDotIndex === -1) {
    return directory + filename + normalizedExtension;
  }
  const nameWithoutExtension = filename.substring(0, lastDotIndex);
  return directory + nameWithoutExtension + normalizedExtension;
}

// packages/bunup/src/build.ts
var ac = null;
async function build(userOptions, rootDir = process.cwd()) {
  ensureMinimumBunVersion();
  if (ac) {
    ac.abort();
  }
  ac = new AbortController;
  const options = resolveBuildOptions(userOptions);
  if (options.silent) {
    logger.setSilent(options.silent);
  }
  if (options.clean) {
    cleanOutDir(rootDir, options.outDir);
  }
  const packageJson = await loadPackageJson(rootDir);
  if (packageJson.data && packageJson.path) {
    logger.info(`Using ${getShortFilePath(packageJson.path, 2)}`, {
      muted: true,
      identifier: options.name,
      once: `${packageJson.path}:${options.name}`
    });
  }
  const packageType = packageJson.data?.type;
  const allPlugins = resolvePlugins(options, packageJson.data);
  const bunupPlugins = filterBunupPlugins(allPlugins);
  const bunPlugins = filterBunPlugins(allPlugins);
  await runPluginBuildStartHooks(bunupPlugins, { options });
  const entryArray = ensureArray(options.entry);
  const entrypoints = getFilesFromGlobs(entryArray, rootDir);
  if (!entrypoints.length) {
    if (!ensureArray(userOptions.entry).length) {
      throw new BunupBuildError(formatNoEntryPointsFoundError(DEFAULT_ENTYPOINTS));
    }
    throw new BunupBuildError(formatInvalidEntryPointsError(entryArray));
  }
  logger.info(`entry: ${formatListWithAnd(entrypoints)}`, {
    identifier: options.name,
    once: options.name,
    muted: true
  });
  const buildOutputFiles = [];
  const absoluteEntrypoints = entrypoints.map((file) => `${rootDir}/${file}`);
  const resolvedDefine = getResolvedDefine(options.define, options.env);
  const resolvedMinify = getResolvedMinify(options);
  const resolvedTarget = getResolvedTarget(options.target);
  const resolvedSourcemap = getResolvedSourcemap(options.sourcemap);
  const resolvedEnv = getResolvedEnv(options.env);
  const chunkNaming = getDefaultChunkNaming(options.name);
  const buildPromises = ensureArray(options.format).map(async (fmt) => {
    const result = await Bun.build({
      entrypoints: absoluteEntrypoints,
      format: fmt,
      splitting: getResolvedSplitting(options.splitting, fmt),
      define: resolvedDefine,
      minify: resolvedMinify,
      target: resolvedTarget,
      sourcemap: resolvedSourcemap,
      loader: options.loader,
      drop: options.drop,
      naming: {
        chunk: chunkNaming,
        entry: options.compile ? getCompileNaming(entryArray, options.compile, fmt) : undefined
      },
      conditions: options.conditions,
      banner: options.banner,
      footer: options.footer,
      publicPath: options.publicPath,
      root: options.sourceBase ? path3.resolve(rootDir, options.sourceBase) : undefined,
      env: resolvedEnv,
      ignoreDCEAnnotations: options.ignoreDCEAnnotations,
      emitDCEAnnotations: options.emitDCEAnnotations,
      packages: options.packages,
      jsx: options.jsx,
      compile: options.compile,
      outdir: options.compile ? path3.resolve(rootDir, options.outDir) : undefined,
      throw: false,
      plugins: bunPlugins,
      tsconfig: options.preferredTsconfig ? path3.resolve(rootDir, options.preferredTsconfig) : undefined
    });
    for (const log of result.logs) {
      if (log.level === "error") {
        throw new BunupBuildError(formatBunBuildError(log));
      }
      if (log.level === "warning")
        logger.warn(log.message);
      if (log.level === "verbose")
        logger.log(log.message);
      else if (log.level === "info")
        logger.info(log.message);
    }
    let entrypointIndex = 0;
    for (const file of result.outputs) {
      if (options.compile) {
        const fullPath2 = file.path;
        const pathRelativeToRootDir2 = path3.relative(rootDir, fullPath2);
        const absoluteOutDir = path3.resolve(rootDir, options.outDir);
        const pathRelativeToOutdir2 = path3.relative(absoluteOutDir, fullPath2);
        buildOutputFiles.push({
          fullPath: fullPath2,
          pathRelativeToRootDir: pathRelativeToRootDir2,
          pathRelativeToOutdir: pathRelativeToOutdir2,
          dts: false,
          format: fmt,
          kind: "executable",
          entrypoint: entryArray[0],
          size: Bun.file(fullPath2).size
        });
        continue;
      }
      const content = await file.text();
      const pathRelativeToOutdir = cleanPath(isJavascriptFile(file.path) && file.kind === "entry-point" ? replaceExtension(file.path, getDefaultJsOutputExtension(fmt, packageType)) : file.path);
      const pathRelativeToRootDir = path3.join(options.outDir, pathRelativeToOutdir);
      const fullPath = path3.resolve(rootDir, pathRelativeToRootDir);
      await Bun.write(fullPath, content);
      if (!buildOutputFiles.some((f) => f.fullPath === fullPath)) {
        buildOutputFiles.push({
          fullPath,
          pathRelativeToRootDir,
          pathRelativeToOutdir,
          dts: false,
          format: fmt,
          kind: file.kind,
          entrypoint: file.kind === "entry-point" ? cleanPath(entrypoints[entrypointIndex] ?? "") : undefined,
          size: file.size
        });
        if (file.kind === "entry-point") {
          entrypointIndex++;
        }
      }
    }
  });
  await Promise.all(buildPromises);
  if (options.dts && !options.compile) {
    try {
      const { entry, splitting, ...dtsOptions } = typeof options.dts === "object" ? options.dts : {};
      const dtsResult = await generateDts(ensureArray(entry ?? entrypoints), {
        cwd: rootDir,
        preferredTsconfig: options.preferredTsconfig,
        splitting: getResolvedDtsSplitting(options.splitting, splitting),
        naming: {
          chunk: getDefaultChunkNaming(options.name)
        },
        root: options.sourceBase ? path3.resolve(rootDir, options.sourceBase) : undefined,
        ...dtsOptions
      });
      if (dtsResult.errors.length && !logger.isSilent()) {
        logIsolatedDeclarationErrors(dtsResult.errors);
      }
      for (const fmt of ensureArray(options.format)) {
        for (const file of dtsResult.files) {
          const dtsExtension = getDefaultDtsOutputExtention(fmt, packageType, file.kind);
          const pathRelativeToOutdir = cleanPath(`${file.pathInfo.outputPathWithoutExtension}${dtsExtension}`);
          const pathRelativeToRootDir = cleanPath(`${options.outDir}/${pathRelativeToOutdir}`);
          const fullPath = path3.join(rootDir, pathRelativeToRootDir);
          await Bun.write(fullPath, file.dts);
          buildOutputFiles.push({
            fullPath,
            pathRelativeToRootDir,
            pathRelativeToOutdir,
            dts: true,
            format: fmt,
            kind: file.kind,
            entrypoint: file.entrypoint ? cleanPath(file.entrypoint) : undefined,
            size: file.dts.length
          });
        }
      }
    } catch (error) {
      throw new BunupDTSBuildError(parseErrorMessage(error));
    }
  }
  const buildResult = {
    files: buildOutputFiles,
    build: {
      options,
      meta: {
        packageJson,
        rootDir
      }
    }
  };
  await runPluginBuildDoneHooks(bunupPlugins, {
    files: buildOutputFiles,
    options,
    meta: {
      packageJson,
      rootDir
    }
  });
  if (options.onSuccess) {
    await executeOnSuccess(options.onSuccess, options, ac.signal);
  }
  return buildResult;
}

export { processLoadedConfigs, resolveBuildOptions, build };
