type Prettify<T> = { [K in keyof T] : T[K] } & {};
type HyphenToCamelCase<S extends string> = S extends `${infer P1}-${infer P2}` ? `${Lowercase<P1>}${Capitalize<HyphenToCamelCase<P2>>}` : S;
type CamelCaseKeys<T> = T extends any ? T extends (infer U)[] ? CamelCaseKeys<U>[] : T extends Record<string, any> ? { [K in keyof T as HyphenToCamelCase<K & string>] : CamelCaseKeys<T[K]> } : T : never;
type ExtractPositionalType<T> = T extends PositionalSchema<infer U> ? U : never;
type ExtractPositionalTypes<T extends readonly PositionalSchema<any>[]> = { readonly [K in keyof T] : ExtractPositionalType<T[K]> };
type ExtractRestType<T extends readonly (PositionalSchema<any> | VariadicPositionalSchema<any>)[]> = T extends readonly [...infer _, VariadicPositionalSchema<infer U>] ? U[] : never;
type ExtractNonRestPositionals<T extends readonly (PositionalSchema<any> | VariadicPositionalSchema<any>)[]> = T extends readonly [...infer P, VariadicPositionalSchema<any>] ? P extends readonly PositionalSchema<any>[] ? ExtractPositionalTypes<P> : readonly [] : T extends readonly PositionalSchema<any>[] ? ExtractPositionalTypes<T> : readonly [];
type SchemaType = "string" | "number" | "boolean" | "array" | "object" | "union";
type UnionToTuple<T> = T extends Schema<infer U>[] ? U : never;
interface ParseOptions {
	ignoreOptionDefaultValue?: boolean;
}
interface BaseSchema<T = any> {
	_type: SchemaType;
	_output: T;
	_input: unknown;
	_description?: string;
	_alias?: string;
	_example?: string;
	_isOptional?: boolean;
	_defaultValue?: T;
	_defaultMessage?: string;
	parse(value: unknown, path?: string): T;
	optional(): Schema<T | undefined>;
	default(value: T, message?: string): Schema<T>;
	transform<U>(fn: (value: T) => U): Schema<U>;
	describe(description: string): this;
	alias(alias: string): this;
	example(example: string): this;
}
type Schema<T = any> = BaseSchema<T>;
interface StringSchema<T extends string = string> extends BaseSchema<T> {
	min(length: number, message?: string): this;
	max(length: number, message?: string): this;
	regex(pattern: RegExp, message?: string): this;
	choices<const U extends readonly string[]>(choices: U): StringSchema<U[number]>;
	_minLength?: number;
	_maxLength?: number;
	_minMessage?: string;
	_maxMessage?: string;
	_regex?: {
		pattern: RegExp
		message?: string
	};
	_choices?: readonly string[];
}
interface NumberSchema extends BaseSchema<number> {
	min(value: number, message?: string): this;
	max(value: number, message?: string): this;
	int(message?: string): this;
	positive(message?: string): this;
	negative(message?: string): this;
	_min?: number;
	_max?: number;
	_minMessage?: string;
	_maxMessage?: string;
	_isInt?: boolean;
	_intMessage?: string;
	_isPositive?: boolean;
	_positiveMessage?: string;
	_isNegative?: boolean;
	_negativeMessage?: string;
}
interface BooleanSchema extends BaseSchema<boolean> {}
interface ArraySchema<T> extends BaseSchema<T[]> {
	min(length: number, message?: string): this;
	max(length: number, message?: string): this;
	_itemSchema: Schema<T>;
	_minLength?: number;
	_maxLength?: number;
	_minMessage?: string;
	_maxMessage?: string;
}
interface ObjectSchema<T extends Record<string, any> = Record<string, any>> extends BaseSchema<T> {
	_shape?: { [K in keyof T] : Schema<T[K]> };
	_isAnyKeys?: boolean;
	_valueSchema?: Schema<any>;
}
interface UnionSchema<T extends readonly Schema[]> extends BaseSchema<UnionToTuple<T>> {
	_schemas: T;
}
interface PositionalSchema<T = string> extends BaseSchema<T> {
	_name: string;
}
interface VariadicPositionalSchema<T = string> extends BaseSchema<T[]> {
	_name: string;
	_isVariadic: true;
	_itemSchema: Schema<T>;
}
interface Command<
	TOptions extends Record<string, Schema> = any,
	TPositionals extends readonly (PositionalSchema<any> | VariadicPositionalSchema<any>)[] = readonly []
> {
	name: string;
	description?: string;
	usage?: string;
	example?: string | string[];
	options: TOptions;
	positionals?: (PositionalSchema<any> | VariadicPositionalSchema<any>)[];
	action: (args: {
		options: Prettify<CamelCaseKeys<{ [K in keyof TOptions] : TOptions[K]["_output"] }>>
		positionals: ExtractNonRestPositionals<TPositionals>
		rest: ExtractRestType<TPositionals>
	}) => void | Promise<void>;
}
interface CommandBuilder<
	TOptions extends Record<string, Schema>,
	TPositionals extends readonly (PositionalSchema<any> | VariadicPositionalSchema<any>)[] = readonly []
> {
	description(desc: string): this;
	usage(usage: string): this;
	example(example: string | string[]): this;
	positional<T>(name: string, schema?: Schema<T>): CommandBuilder<TOptions, [...TPositionals, PositionalSchema<T>]>;
	rest<T>(name: string, schema?: Schema<T>): CommandBuilder<TOptions, [...TPositionals, VariadicPositionalSchema<T>]>;
	action(fn: (args: {
		options: Prettify<CamelCaseKeys<{ [K in keyof TOptions] : TOptions[K]["_output"] }>>
		positionals: ExtractNonRestPositionals<TPositionals>
		rest: ExtractRestType<TPositionals>
	}) => void | Promise<void>): Command<TOptions, TPositionals>;
}
interface CLI<
	TOptions extends Record<string, Schema> = Record<string, never>,
	TPositionals extends readonly (PositionalSchema<any> | VariadicPositionalSchema<any>)[] = readonly []
> {
	name(name: string): this;
	version(version: string): this;
	description(description: string): this;
	usage(usage: string): this;
	example(example: string | string[]): this;
	option<
		K extends string,
		S extends Schema
	>(name: K, schema: S): CLI<TOptions & { [P in K] : S }, TPositionals>;
	positional<T>(name: string, schema?: Schema<T>): CLI<TOptions, [...TPositionals, PositionalSchema<T>]>;
	rest<T>(name: string, schema?: Schema<T>): CLI<TOptions, [...TPositionals, VariadicPositionalSchema<T>]>;
	command<T extends Record<string, Schema> = Record<string, never>>(name: string, options?: T): CommandBuilder<T>;
	with(options: ParseOptions): this;
	parse(argv?: string[]): {
		options: Prettify<CamelCaseKeys<{ [K in keyof TOptions] : TOptions[K]["_output"] }>>
		positionals: ExtractNonRestPositionals<TPositionals>
		rest: ExtractRestType<TPositionals>
	} | undefined;
}
declare const z: {
	string: () => StringSchema
	number: () => NumberSchema
	boolean: () => BooleanSchema
	array: <T>(schema: Schema<T>) => ArraySchema<T>
	object: <T extends Record<string, Schema> | Schema = never>(shapeOrValueSchema: T) => T extends Record<string, Schema> ? ObjectSchema<{ [K in keyof T] : T[K]["_output"] }> : T extends Schema ? ObjectSchema<Record<string, T["_output"]>> : never
	union: <T extends readonly Schema[]>(...schemas: T) => UnionSchema<T>
};
declare function cli(): CLI<Record<string, never>, readonly []>;
export { z, cli };
