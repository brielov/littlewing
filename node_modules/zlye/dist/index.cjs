var import_node_module = require("node:module");
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// src/index.ts
var exports_src = {};
__export(exports_src, {
  z: () => z,
  cli: () => cli
});
module.exports = __toCommonJS(exports_src);
var import_picocolors = __toESM(require("picocolors"));

// src/utils.ts
function joinWithAnd(items) {
  return new Intl.ListFormat("en", { type: "conjunction" }).format(items);
}
function processExit(code, error) {
  if (!process.env.NO_EXIT) {
    process.exit(code);
  } else if (error) {
    throw error;
  }
}

// src/index.ts
function hyphenToCamelCase(str) {
  if (str.includes("--") || str.startsWith("-") || str.endsWith("-")) {
    return str;
  }
  return str.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
}
class CLIError extends Error {
  constructor(message) {
    super(message);
    this.name = "CLIError";
  }
}

class ErrorFormatter {
  static formatValue(value) {
    if (value === null)
      return import_picocolors.default.red("null");
    if (value === undefined)
      return import_picocolors.default.red("undefined");
    if (typeof value === "string")
      return import_picocolors.default.red(`"${value}"`);
    if (typeof value === "number")
      return import_picocolors.default.yellow(String(value));
    if (typeof value === "boolean")
      return import_picocolors.default.cyan(String(value));
    if (Array.isArray(value)) {
      if (!value.length)
        return import_picocolors.default.red("[]");
      if (value.length <= 3)
        return import_picocolors.default.red("[") + value.map((v) => this.formatValue(v)).join(", ") + import_picocolors.default.red("]");
      return import_picocolors.default.red(`[${value.length} items]`);
    }
    if (typeof value === "object" && value !== null) {
      const keys = Object.keys(value);
      if (!keys.length)
        return import_picocolors.default.red("{}");
      if (keys.length <= 3)
        return import_picocolors.default.red("{") + keys.join(", ") + import_picocolors.default.red("}");
      return import_picocolors.default.red(`{${keys.length} keys}`);
    }
    return import_picocolors.default.red(String(value));
  }
  static formatCorrectUsage(flagName, value, schema, isNested = false) {
    const prefix = isNested ? "" : "--";
    const type = schema._type;
    if (type === "boolean")
      return `${import_picocolors.default.green(`${prefix}${flagName}`)} ${import_picocolors.default.dim("or")} ${import_picocolors.default.green(`${prefix}${flagName} true`)}`;
    if (type === "number") {
      const num = schema;
      let example = 42;
      if (num._min !== undefined)
        example = Math.max(example, num._min);
      if (num._max !== undefined)
        example = Math.min(example, num._max);
      if (num._isPositive && example <= 0)
        example = 1;
      if (num._isNegative && example >= 0)
        example = -1;
      if (num._isInt)
        example = Math.floor(example);
      return import_picocolors.default.green(`${prefix}${flagName} ${example}`);
    }
    if (type === "string") {
      const str = schema;
      if (str._choices?.length)
        return import_picocolors.default.green(`${prefix}${flagName} ${str._choices[0]}`);
      const example = str._minLength ? "x".repeat(str._minLength) : "value";
      return import_picocolors.default.green(`${prefix}${flagName} "${example}"`);
    }
    if (type === "array") {
      const arr = schema;
      const item = this.getExampleValue(arr._itemSchema);
      const examples = Array(arr._minLength || 1).fill(item);
      return import_picocolors.default.green(`${prefix}${flagName} ${examples.join(",")}`);
    }
    if (type === "object") {
      const obj = schema;
      if (obj._isAnyKeys) {
        const value2 = obj._valueSchema ? this.getExampleValue(obj._valueSchema) : "value";
        return import_picocolors.default.green(`${prefix}${flagName}.key ${value2}`);
      }
      if (obj._shape) {
        const keys = Object.keys(obj._shape);
        if (keys.length) {
          const key = keys[0];
          const displayKey = obj.getOriginalKey ? obj.getOriginalKey(key) : key;
          return import_picocolors.default.green(`${prefix}${flagName}.${displayKey} ${this.getExampleValue(obj._shape[key])}`);
        }
      }
    }
    if (type === "union") {
      const union = schema;
      const matchingSchema = union._schemas.find((s) => s._type === typeof value || s._type === "array" && Array.isArray(value)) || union._schemas.find((s) => s._type !== "object") || union._schemas[0];
      return this.formatCorrectUsage(flagName, value, matchingSchema, isNested);
    }
    return import_picocolors.default.green(`${prefix}${flagName} <value>`);
  }
  static getExampleValue(schema) {
    if (schema._example)
      return schema._example;
    const type = schema._type;
    if (type === "boolean")
      return "true";
    if (type === "number") {
      const num = schema;
      let example = 42;
      if (num._min !== undefined)
        example = Math.max(example, num._min);
      if (num._max !== undefined)
        example = Math.min(example, num._max);
      if (num._isPositive && example <= 0)
        example = 1;
      if (num._isNegative && example >= 0)
        example = -1;
      if (num._isInt)
        example = Math.floor(example);
      return String(example);
    }
    if (type === "string") {
      const str = schema;
      return str._choices?.length ? str._choices[0] : "value";
    }
    if (type === "array") {
      const arr = schema;
      const item = this.getExampleValue(arr._itemSchema);
      return `${item},${item}`;
    }
    return "value";
  }
  static showDiff(received, expected) {
    return `${import_picocolors.default.dim("  Received: ")}${import_picocolors.default.red(received)}
${import_picocolors.default.dim("  Expected: ")}${import_picocolors.default.green(expected)}`;
  }
}

class BaseSchemaImpl {
  _output;
  _input;
  _description;
  _alias;
  _example;
  _isOptional;
  _defaultValue;
  _defaultMessage;
  parse(value, path = "value") {
    if (value === undefined) {
      if (this._isOptional)
        return;
      if (this._defaultValue !== undefined)
        return this._defaultValue;
      throw new CLIError(`${path} is required`);
    }
    return this.validateValue(value, path);
  }
  optional() {
    const clone = Object.create(this);
    clone._isOptional = true;
    return clone;
  }
  default(value, message) {
    const clone = Object.create(this);
    clone._defaultValue = value;
    clone._defaultMessage = message;
    return clone;
  }
  transform(fn) {
    const clone = Object.create(this);
    const originalParse = clone.parse.bind(clone);
    clone.parse = (value, path) => fn(originalParse(value, path));
    return clone;
  }
  describe(description) {
    this._description = description;
    return this;
  }
  alias(alias) {
    this._alias = alias;
    return this;
  }
  example(example) {
    this._example = example;
    return this;
  }
}

class StringSchemaImpl extends BaseSchemaImpl {
  _type = "string";
  _minLength;
  _maxLength;
  _minMessage;
  _maxMessage;
  _regex;
  _choices;
  validateValue(value, path) {
    if (typeof value !== "string") {
      const flagName = path.replace("--", "");
      const isArg = !path.startsWith("--");
      throw new CLIError(`${path} expects a text value

${ErrorFormatter.showDiff(isArg ? `${flagName} ${ErrorFormatter.formatValue(value)}` : `--${flagName} ${ErrorFormatter.formatValue(value)}`, isArg ? `${flagName} "value"` : ErrorFormatter.formatCorrectUsage(flagName, value, this))}`);
    }
    if (this._choices && !this._choices.includes(value)) {
      const flagName = path.replace("--", "");
      const isArg = !path.startsWith("--");
      const similar = this._choices.find((c) => c.toLowerCase().includes(value.toLowerCase()) || value.toLowerCase().includes(c.toLowerCase()));
      const choices = Array.from(this._choices);
      let message = `${path} must be one of: ${choices.map((c) => import_picocolors.default.cyan(c)).join(", ")}

`;
      message += similar ? `${ErrorFormatter.showDiff(isArg ? `${flagName} ${value}` : `--${flagName} ${value}`, isArg ? `${flagName} ${similar}` : `--${flagName} ${similar}`)}

${import_picocolors.default.dim("Did you mean")} ${import_picocolors.default.green(similar)}${import_picocolors.default.dim("?")}` : ErrorFormatter.showDiff(isArg ? `${flagName} ${value}` : `--${flagName} ${value}`, isArg ? `${flagName} ${choices[0]}` : `--${flagName} ${choices[0]}`);
      throw new CLIError(message);
    }
    if (this._minLength !== undefined && value.length < this._minLength) {
      const flagName = path.replace("--", "");
      const isArg = !path.startsWith("--");
      const padded = value + "x".repeat(this._minLength - value.length);
      throw new CLIError(this._minMessage || `${path} must be at least ${this._minLength} characters

${ErrorFormatter.showDiff(`${isArg ? "" : "--"}${flagName} "${value}" ${import_picocolors.default.dim(`(${value.length} chars)`)}`, `${isArg ? "" : "--"}${flagName} "${padded}" ${import_picocolors.default.dim(`(${padded.length} chars)`)}`)}`);
    }
    if (this._maxLength !== undefined && value.length > this._maxLength) {
      const flagName = path.replace("--", "");
      const isArg = !path.startsWith("--");
      const truncated = value.slice(0, this._maxLength);
      throw new CLIError(this._maxMessage || `${path} must be at most ${this._maxLength} characters

${ErrorFormatter.showDiff(`${isArg ? "" : "--"}${flagName} "${value}" ${import_picocolors.default.dim(`(${value.length} chars)`)}`, `${isArg ? "" : "--"}${flagName} "${truncated}" ${import_picocolors.default.dim(`(${truncated.length} chars)`)}`)}`);
    }
    if (this._regex && !this._regex.pattern.test(value)) {
      throw new CLIError(this._regex.message || `${path} format is invalid

  ${import_picocolors.default.dim("Received:")} ${import_picocolors.default.red(`"${value}"`)}
  ${import_picocolors.default.dim("Pattern:")} ${import_picocolors.default.cyan(this._regex.pattern.toString())}`);
    }
    return value;
  }
  min(length, message) {
    this._minLength = length;
    this._minMessage = message;
    return this;
  }
  max(length, message) {
    this._maxLength = length;
    this._maxMessage = message;
    return this;
  }
  regex(pattern, message) {
    this._regex = { pattern, message };
    return this;
  }
  choices(choices) {
    const clone = Object.create(this);
    clone._choices = choices;
    return clone;
  }
}

class NumberSchemaImpl extends BaseSchemaImpl {
  _type = "number";
  _min;
  _max;
  _minMessage;
  _maxMessage;
  _isInt;
  _intMessage;
  _isPositive;
  _positiveMessage;
  _isNegative;
  _negativeMessage;
  validateValue(value, path) {
    const num = Number(value);
    const flagName = path.replace("--", "");
    const isArg = !path.startsWith("--");
    if (Number.isNaN(num)) {
      throw new CLIError(`${path} expects a numeric value

${ErrorFormatter.showDiff(`${isArg ? "" : "--"}${flagName} ${ErrorFormatter.formatValue(value)}`, isArg ? `${flagName} 42` : ErrorFormatter.formatCorrectUsage(flagName, value, this))}`);
    }
    if (this._isInt && !Number.isInteger(num)) {
      throw new CLIError(this._intMessage || `${path} must be a whole number

${ErrorFormatter.showDiff(`${isArg ? "" : "--"}${flagName} ${num}`, `${isArg ? "" : "--"}${flagName} ${Math.floor(num)}`)}`);
    }
    if (this._isPositive && num <= 0) {
      throw new CLIError(this._positiveMessage || `${path} must be positive

${ErrorFormatter.showDiff(`${isArg ? "" : "--"}${flagName} ${num}`, `${isArg ? "" : "--"}${flagName} ${Math.abs(num) || 1}`)}`);
    }
    if (this._isNegative && num >= 0) {
      throw new CLIError(this._negativeMessage || `${path} must be negative

${ErrorFormatter.showDiff(`${isArg ? "" : "--"}${flagName} ${num}`, `${isArg ? "" : "--"}${flagName} ${num === 0 ? -1 : -Math.abs(num)}`)}`);
    }
    if (this._min !== undefined && num < this._min) {
      throw new CLIError(this._minMessage || `${path} must be at least ${this._min}

${ErrorFormatter.showDiff(`${isArg ? "" : "--"}${flagName} ${num}`, `${isArg ? "" : "--"}${flagName} ${this._min}`)}`);
    }
    if (this._max !== undefined && num > this._max) {
      throw new CLIError(this._maxMessage || `${path} must be at most ${this._max}

${ErrorFormatter.showDiff(`${isArg ? "" : "--"}${flagName} ${num}`, `${isArg ? "" : "--"}${flagName} ${this._max}`)}`);
    }
    return num;
  }
  min(value, message) {
    this._min = value;
    this._minMessage = message;
    return this;
  }
  max(value, message) {
    this._max = value;
    this._maxMessage = message;
    return this;
  }
  int(message) {
    this._isInt = true;
    this._intMessage = message;
    return this;
  }
  positive(message) {
    this._isPositive = true;
    this._positiveMessage = message;
    return this;
  }
  negative(message) {
    this._isNegative = true;
    this._negativeMessage = message;
    return this;
  }
}

class BooleanSchemaImpl extends BaseSchemaImpl {
  _type = "boolean";
  validateValue(value, path) {
    const truthy = ["true", true, "1", 1];
    const falsy = ["false", false, "0", 0];
    if (truthy.includes(value))
      return true;
    if (falsy.includes(value))
      return false;
    const flagName = path.replace("--", "");
    const isArg = !path.startsWith("--");
    throw new CLIError(`${path} expects a boolean value

${ErrorFormatter.showDiff(`${isArg ? "" : "--"}${flagName} ${ErrorFormatter.formatValue(value)}`, `${isArg ? "" : "--"}${flagName} true`)}

${import_picocolors.default.dim("Valid values: ")}${import_picocolors.default.cyan("true, false, 1, 0")}`);
  }
  parse(value, path = "value") {
    if (value === undefined) {
      if (this._isOptional)
        return;
      if (this._defaultValue !== undefined)
        return this._defaultValue;
      return false;
    }
    return this.validateValue(value, path);
  }
}

class ArraySchemaImpl extends BaseSchemaImpl {
  _type = "array";
  _itemSchema;
  _minLength;
  _maxLength;
  _minMessage;
  _maxMessage;
  constructor(itemSchema) {
    super();
    this._itemSchema = itemSchema;
  }
  validateValue(value, path) {
    const arr = Array.isArray(value) ? value : typeof value === "string" && value.includes(",") ? value.split(",").map((item) => item.trim()).filter(Boolean) : [value];
    const flagName = path.replace("--", "");
    const isArg = !path.startsWith("--");
    if (this._minLength !== undefined && arr.length < this._minLength) {
      const item = ErrorFormatter.getExampleValue(this._itemSchema);
      const examples = Array(this._minLength).fill(item);
      throw new CLIError(this._minMessage || `${path} needs at least ${this._minLength} items

${ErrorFormatter.showDiff(`${isArg ? "" : "--"}${flagName} ${arr.join(",")} ${import_picocolors.default.dim(`(${arr.length} items)`)}`, `${isArg ? "" : "--"}${flagName} ${examples.join(",")} ${import_picocolors.default.dim(`(${examples.length} items)`)}`)}`);
    }
    if (this._maxLength !== undefined && arr.length > this._maxLength) {
      const limited = arr.slice(0, this._maxLength);
      throw new CLIError(this._maxMessage || `${path} allows at most ${this._maxLength} items

${ErrorFormatter.showDiff(`${isArg ? "" : "--"}${flagName} ${arr.join(",")} ${import_picocolors.default.dim(`(${arr.length} items)`)}`, `${isArg ? "" : "--"}${flagName} ${limited.join(",")} ${import_picocolors.default.dim(`(${limited.length} items)`)}`)}`);
    }
    const results = [];
    const errors = [];
    for (let i = 0;i < arr.length; i++) {
      try {
        results.push(this._itemSchema.parse(arr[i], `${path}[${i}]`));
      } catch (error) {
        if (error instanceof CLIError) {
          errors.push({
            index: i,
            error: error.message.split(`
`)[0].replace(`${path}[${i}]`, `Item ${i + 1}`)
          });
        }
      }
    }
    if (errors.length) {
      const item = ErrorFormatter.getExampleValue(this._itemSchema);
      const valid = arr.map((v, i) => errors.find((e) => e.index === i) ? item : v);
      let message = `${path} has invalid items

`;
      for (const { error } of errors)
        message += `  ${import_picocolors.default.red(">")} ${error}
`;
      message += `
${ErrorFormatter.showDiff(`${isArg ? "" : "--"}${flagName} ${arr.join(",")}`, `${isArg ? "" : "--"}${flagName} ${valid.join(",")}`)}`;
      throw new CLIError(message);
    }
    return results;
  }
  min(length, message) {
    this._minLength = length;
    this._minMessage = message;
    return this;
  }
  max(length, message) {
    this._maxLength = length;
    this._maxMessage = message;
    return this;
  }
}

class ObjectSchemaImpl extends BaseSchemaImpl {
  _type = "object";
  _shape;
  _isAnyKeys;
  _valueSchema;
  _originalShape;
  constructor(shapeOrValueSchema) {
    super();
    if (!shapeOrValueSchema) {
      throw new CLIError(`Configuration expects either specific properties or a value schema

${import_picocolors.default.dim(`Examples:
`)}  ${import_picocolors.default.green("{ name: string(), age: number() }")}  ${import_picocolors.default.dim("for specific properties")}
  ${import_picocolors.default.green("string()")}                           ${import_picocolors.default.dim("for any properties with string values")}`);
    }
    if (shapeOrValueSchema && typeof shapeOrValueSchema === "object" && "_type" in shapeOrValueSchema) {
      this._isAnyKeys = true;
      this._valueSchema = shapeOrValueSchema;
    } else {
      this._originalShape = shapeOrValueSchema;
      const convertedShape = {};
      for (const [key, value] of Object.entries(shapeOrValueSchema)) {
        const camelKey = hyphenToCamelCase(key);
        convertedShape[camelKey] = value;
      }
      this._shape = convertedShape;
      this._isAnyKeys = false;
    }
  }
  getOriginalKey(camelKey) {
    if (!this._originalShape)
      return camelKey;
    for (const [originalKey, _] of Object.entries(this._originalShape)) {
      if (hyphenToCamelCase(originalKey) === camelKey) {
        return originalKey;
      }
    }
    return camelKey;
  }
  validateValue(value, path) {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      const flagName = path.replace("--", "");
      let correctUsage = "";
      if (this._originalShape || this._shape) {
        const shape = this._originalShape || this._shape;
        const keys = Object.keys(shape || {});
        if (keys.length) {
          const key = keys[0];
          const example = ErrorFormatter.getExampleValue(shape[key]);
          correctUsage = `--${flagName}.${key} ${example}`;
        }
      } else if (this._isAnyKeys) {
        const example = this._valueSchema ? ErrorFormatter.getExampleValue(this._valueSchema) : "value";
        correctUsage = `--${flagName}.property ${example}`;
      }
      throw new CLIError(`${path} expects property assignments

  ${import_picocolors.default.dim("Received:")} ${ErrorFormatter.formatValue(value)}
  ${import_picocolors.default.dim("Expected:")} ${import_picocolors.default.green(correctUsage)}

${import_picocolors.default.dim("Use dot notation to set properties: ")}${import_picocolors.default.cyan(`--${flagName}.key value`)}`);
    }
    const objectValue = value;
    if (this._isAnyKeys && this._valueSchema) {
      const result = {};
      for (const [key, val] of Object.entries(objectValue)) {
        result[key] = this._valueSchema.parse(val, `${path}.${key}`);
      }
      return result;
    }
    if (this._shape) {
      const result = {};
      const shapeKeys = new Set(Object.keys(this._shape));
      const unknownKeys = Object.keys(objectValue).filter((k) => !shapeKeys.has(k));
      if (unknownKeys.length) {
        const validKeys = Array.from(shapeKeys);
        const originalValidKeys = validKeys.map((k) => this.getOriginalKey(k));
        const suggestions = unknownKeys.map((uk) => {
          const similar = validKeys.find((vk) => vk.toLowerCase() === uk.toLowerCase() || vk.toLowerCase().includes(uk.toLowerCase()) || uk.toLowerCase().includes(vk.toLowerCase()));
          const originalSimilar = similar ? this.getOriginalKey(similar) : null;
          return originalSimilar ? `${import_picocolors.default.red(uk)} â†’ ${import_picocolors.default.green(originalSimilar)}` : import_picocolors.default.red(uk);
        });
        const flagName = path.replace("--", "");
        throw new CLIError(`${path} received unexpected properties

  ${import_picocolors.default.red("Invalid:")} ${suggestions.join(", ")}
  ${import_picocolors.default.green("Valid:")} ${originalValidKeys.map((k) => import_picocolors.default.cyan(k)).join(", ")}

${import_picocolors.default.dim(`Available properties:
`)}${originalValidKeys.map((k) => `  ${import_picocolors.default.cyan(`--${flagName}.${k}`)}`).join(`
`)}`);
      }
      for (const [key, schema] of Object.entries(this._shape)) {
        const originalKey = this.getOriginalKey(key);
        result[key] = schema.parse(objectValue[key], `${path}.${originalKey}`);
      }
      return result;
    }
    throw new CLIError(`${path} configuration error`);
  }
  getMissingRequiredFields(value) {
    if (!this._shape || typeof value !== "object" || value === null)
      return [];
    const missing = [];
    const objectValue = value;
    for (const [key, schema] of Object.entries(this._shape)) {
      if (!(key in objectValue) && !schema._isOptional && schema._defaultValue === undefined) {
        missing.push(key);
      }
    }
    return missing;
  }
}

class UnionSchemaImpl extends BaseSchemaImpl {
  _type = "union";
  _schemas;
  constructor(schemas) {
    super();
    this._schemas = schemas;
  }
  validateValue(value, path) {
    const errors = [];
    const sortedSchemas = [...this._schemas].sort((a, b) => a._type === "number" && b._type === "string" ? -1 : a._type === "string" && b._type === "number" ? 1 : 0);
    for (const schema of sortedSchemas) {
      try {
        return schema.parse(value, path);
      } catch (error) {
        if (error instanceof CLIError) {
          let specificity = 0;
          if (schema._type === "object" && typeof value === "object" && value !== null) {
            const objSchema = schema;
            const providedKeys = Object.keys(value);
            const missingFields = objSchema.getMissingRequiredFields(value);
            if (providedKeys.length && objSchema._shape) {
              const validKeys = providedKeys.filter((k) => (k in objSchema._shape));
              specificity = validKeys.length * 10;
              if (missingFields.length)
                specificity += 5;
              const invalidKeys = providedKeys.filter((k) => !(k in objSchema._shape));
              if (invalidKeys.length && validKeys.length === 0) {
                const allValidKeys = Object.keys(objSchema._shape);
                const originalValidKeys = allValidKeys.map((k) => objSchema instanceof ObjectSchemaImpl ? objSchema.getOriginalKey(k) : k);
                const flagName2 = path.replace("--", "");
                throw new CLIError(`${path} has invalid properties: ${import_picocolors.default.red("{" + invalidKeys.join(", ") + "}")}

${import_picocolors.default.dim("Available properties for object format:")}
${originalValidKeys.map((k) => `  ${import_picocolors.default.green(`--${flagName2}.${k}`)} <value>`).join(`
`)}

${import_picocolors.default.dim("Or use other formats:")}
  ${import_picocolors.default.green(`--${flagName2}`)} ${import_picocolors.default.dim("(boolean)")}
  ${import_picocolors.default.green(`--${flagName2} value`)} ${import_picocolors.default.dim("(simple value)")}`);
              }
            }
          } else if (schema._type === typeof value) {
            specificity = 1;
          }
          errors.push({ schema, error: error.message, specificity });
        }
      }
    }
    errors.sort((a, b) => b.specificity - a.specificity);
    if (errors[0]?.specificity > 0) {
      throw new CLIError(errors[0].error);
    }
    const flagName = path.replace("--", "");
    const examples = this.getExampleUsages(flagName, value);
    throw new CLIError(`${path} accepts multiple formats

${import_picocolors.default.dim("Valid formats:")}
${examples.map((ex) => `  ${ex}`).join(`
`)}

  ${import_picocolors.default.dim("You provided:")} ${ErrorFormatter.formatValue(value)}

${import_picocolors.default.dim("Run with --help for usage information")}`);
  }
  getExampleUsages(flagName, providedValue) {
    const examples = [];
    const seenTypes = new Set;
    const providedKeys = typeof providedValue === "object" && providedValue !== null && !Array.isArray(providedValue) ? Object.keys(providedValue) : [];
    for (const schema of this._schemas) {
      if (schema._type === "object") {
        const objSchema = schema;
        if (objSchema._isAnyKeys) {
          examples.push(`${import_picocolors.default.green(`--${flagName}.key value`)} ${import_picocolors.default.dim("(dynamic properties)")}`);
        } else if (objSchema._shape) {
          const keys = Object.keys(objSchema._shape);
          if (keys.length) {
            if (providedKeys.length) {
              examples.push(`${import_picocolors.default.dim("Object properties:")}
${keys.map((k) => `    ${import_picocolors.default.green(`--${flagName}.${k}`)} <value>`).join(`
`)}`);
            } else {
              examples.push(`${import_picocolors.default.green(`--${flagName}.property value`)} ${import_picocolors.default.dim(`(object properties: ${keys.slice(0, 3).join(", ")}${keys.length > 3 ? "..." : ""})`)}`);
            }
          }
        }
      } else if (!seenTypes.has(schema._type)) {
        seenTypes.add(schema._type);
        const example = ErrorFormatter.formatCorrectUsage(flagName, undefined, schema);
        const typeLabel = schema._type === "boolean" ? "flag" : schema._type;
        examples.push(`${example} ${import_picocolors.default.dim(`(${typeLabel})`)}`);
      }
    }
    return examples;
  }
}

class PositionalSchemaImpl extends BaseSchemaImpl {
  _type = "string";
  _name;
  _baseSchema;
  constructor(name, schema) {
    super();
    this._name = name;
    this._baseSchema = schema || new StringSchemaImpl;
    this._isOptional = this._baseSchema._isOptional;
    this._defaultValue = this._baseSchema._defaultValue;
    this._defaultMessage = this._baseSchema._defaultMessage;
    this._description = this._baseSchema._description;
  }
  validateValue(value, path) {
    return this._baseSchema.parse(value, path || this._name);
  }
  parse(value, path = "value") {
    return this._baseSchema.parse(value, path);
  }
}

class VariadicPositionalSchemaImpl extends BaseSchemaImpl {
  _type = "array";
  _name;
  _itemSchema;
  _isVariadic = true;
  constructor(name, schema) {
    super();
    this._name = name;
    this._itemSchema = schema || new StringSchemaImpl;
    this._description = schema?._description;
  }
  validateValue(values, path) {
    if (!Array.isArray(values)) {
      throw new CLIError(`${path} expects multiple values

  ${import_picocolors.default.dim("Received:")} ${ErrorFormatter.formatValue(values)}
  ${import_picocolors.default.dim("Expected:")} ${import_picocolors.default.green("value1 value2 value3...")}`);
    }
    return values.map((value, i) => this._itemSchema.parse(value, `${path}[${i}]`));
  }
  parse(value, path = "value") {
    if (value === undefined || Array.isArray(value) && !value.length) {
      if (this._isOptional || this._defaultValue !== undefined)
        return this._defaultValue || [];
      return [];
    }
    return this.validateValue(value, path);
  }
}

class CommandBuilderImpl {
  _name;
  _options;
  _description;
  _usage;
  _examples;
  _positionals;
  constructor(_name, _options, _description, _usage, _examples = [], _positionals = []) {
    this._name = _name;
    this._options = _options;
    this._description = _description;
    this._usage = _usage;
    this._examples = _examples;
    this._positionals = _positionals;
  }
  description(desc) {
    this._description = desc;
    return this;
  }
  usage(usage) {
    this._usage = usage;
    return this;
  }
  example(example) {
    this._examples.push(...Array.isArray(example) ? example : [example]);
    return this;
  }
  positional(name, schema) {
    if (this._positionals.some((p) => ("_isVariadic" in p) && p._isVariadic)) {
      throw new CLIError("Cannot add positional after variadic positional");
    }
    this._positionals.push(new PositionalSchemaImpl(name, schema));
    return this;
  }
  rest(name, schema) {
    if (this._positionals.some((p) => ("_isVariadic" in p) && p._isVariadic)) {
      throw new CLIError("Cannot have multiple variadic positionals");
    }
    this._positionals.push(new VariadicPositionalSchemaImpl(name, schema));
    return this;
  }
  action(fn) {
    return {
      name: this._name,
      description: this._description,
      usage: this._usage,
      example: this._examples.length ? this._examples : undefined,
      options: this._options,
      positionals: this._positionals,
      action: fn
    };
  }
}

class HelpFormatter {
  cli;
  constructor(cli) {
    this.cli = cli;
  }
  showHelp() {
    this.printHeader();
    this.printUsage();
    this.printPositionals();
    this.printCommands();
    this.printOptions();
    this.printExamples();
  }
  showCommandHelp(command) {
    console.log();
    this.printCommandUsage(command);
    this.printCommandDescription(command);
    this.printCommandPositionals(command);
    this.printCommandOptions(command);
    this.printCommandExamples(command);
  }
  showError(error) {
    console.error();
    const message = error instanceof Error ? error.message : String(error);
    console.error(`${import_picocolors.default.red(import_picocolors.default.bold("Error:"))} ${message}`);
    console.error(`
${import_picocolors.default.dim(import_picocolors.default.blue(`Run with ${import_picocolors.default.bold("--help")} for usage information`))}`);
  }
  printHeader() {
    console.log();
    const { _name, _version, _description } = this.cli;
    if (_description && _version) {
      console.log(`${_description} ${import_picocolors.default.dim(`(${_version})`)}`);
      console.log();
    } else if (_name) {
      console.log(import_picocolors.default.bold(_name));
      if (_version)
        console.log(import_picocolors.default.dim(`v${_version}`));
      if (_description) {
        console.log();
        console.log(_description);
      }
      console.log();
    }
  }
  printUsage() {
    if (this.cli._usage) {
      console.log(`${import_picocolors.default.bold("Usage:")} ${this.cli._usage}`);
    } else {
      const parts = [this.cli._name || "cli"];
      if (this.cli._commands.length)
        parts.push(import_picocolors.default.blue("<command>"));
      if (this.cli._positionals.length) {
        parts.push(...this.cli._positionals.map((p) => ("_isVariadic" in p) && p._isVariadic ? import_picocolors.default.dim(`[...${p._name}]`) : import_picocolors.default.dim(`<${p._name}>`)));
      }
      if (Object.keys(this.cli._options).length)
        parts.push(import_picocolors.default.blue("[...flags]"));
      console.log(`${import_picocolors.default.bold("Usage:")} ${parts.join(" ")}`);
    }
    console.log();
  }
  printPositionals() {
    if (!this.cli._positionals.length)
      return;
    console.log(import_picocolors.default.bold("Arguments:"));
    for (const pos of this.cli._positionals) {
      const isVariadic = "_isVariadic" in pos && pos._isVariadic;
      const name = isVariadic ? `[...${pos._name}]` : `<${pos._name}>`;
      console.log(`  ${import_picocolors.default.cyan(name)}  ${pos._description || ""}`);
    }
    console.log();
  }
  printCommands() {
    if (!this.cli._commands.length)
      return;
    console.log(import_picocolors.default.bold("Commands:"));
    const rows = this.cli._commands.map((cmd) => ({
      name: cmd.name,
      example: Array.isArray(cmd.example) ? cmd.example[0] : cmd.example || "",
      description: cmd.description || ""
    }));
    const nameWidth = Math.max(...rows.map((r) => r.name.length));
    const exampleWidth = Math.max(...rows.map((r) => r.example.length));
    for (const { name, example, description } of rows) {
      console.log(`  ${import_picocolors.default.cyan(name.padEnd(nameWidth))}  ${example ? import_picocolors.default.dim(example.padEnd(exampleWidth)) : " ".repeat(exampleWidth)}  ${description}`);
    }
    console.log(`  ${import_picocolors.default.cyan("<command> --help".padEnd(nameWidth))}${exampleWidth ? `  ${" ".repeat(exampleWidth)}` : ""}  ${import_picocolors.default.dim("Print help text for command.")}`);
    console.log();
  }
  printOptions() {
    if (!Object.keys(this.cli._options).length)
      return;
    console.log(import_picocolors.default.bold("Flags:"));
    this.printOptionsTable(this.cli._options);
    console.log();
  }
  printExamples() {
    if (!this.cli._examples.length)
      return;
    console.log(import_picocolors.default.bold("Examples:"));
    for (const example of this.cli._examples) {
      this.printExample(example);
    }
  }
  printCommandUsage(command) {
    const usage = command.usage || this.buildCommandUsage(command);
    console.log(`${import_picocolors.default.bold("Usage:")} ${usage}`);
    console.log();
  }
  printCommandDescription(command) {
    if (!command.description)
      return;
    console.log(`  ${command.description}`);
    console.log();
  }
  printCommandPositionals(command) {
    if (!command.positionals?.length)
      return;
    console.log(import_picocolors.default.bold("Arguments:"));
    for (const pos of command.positionals) {
      const isVariadic = "_isVariadic" in pos && pos._isVariadic;
      const name = isVariadic ? `[...${pos._name}]` : `<${pos._name}>`;
      console.log(`  ${import_picocolors.default.cyan(name)}  ${pos._description || ""}`);
    }
    console.log();
  }
  printCommandOptions(command) {
    if (!Object.keys(command.options).length)
      return;
    console.log(import_picocolors.default.bold("Flags:"));
    this.printOptionsTable(command.options);
    console.log();
  }
  printCommandExamples(command) {
    const examples = Array.isArray(command.example) ? command.example : command.example ? [command.example] : [];
    if (!examples.length)
      return;
    console.log(import_picocolors.default.bold("Examples:"));
    for (const example of examples) {
      this.printExample(example);
    }
  }
  printOptionsTable(options) {
    const rows = this.buildOptionRows(options);
    const flagsWidth = Math.max(...rows.map((r) => r.flags.length));
    const typeWidth = Math.max(...rows.map((r) => r.type.length));
    for (const { flags, type, desc } of rows) {
      if (!flags && !type && !desc) {
        console.log();
      } else {
        console.log(`  ${import_picocolors.default.cyan(flags.padEnd(flagsWidth))}${type.padEnd(typeWidth)}  ${desc}`);
      }
    }
    console.log(`  ${import_picocolors.default.cyan("-h, --help".padEnd(flagsWidth))}${import_picocolors.default.dim("").padEnd(typeWidth)}  ${import_picocolors.default.dim("Display this menu and exit")}`);
  }
  buildOptionRows(options, prefix = "", addedNoVersions = new Set) {
    const rows = [];
    for (const [key, schema] of Object.entries(options)) {
      const fullKey = prefix ? `${prefix}.${key}` : key;
      if (schema._type === "union") {
        rows.push(...this.buildUnionRows(fullKey, schema, addedNoVersions));
      } else if (schema._type === "object" && !schema._isAnyKeys && (schema._originalShape || schema._shape)) {
        const shape = schema._originalShape || schema._shape;
        rows.push(...this.buildOptionRows(shape, fullKey, addedNoVersions));
      } else {
        rows.push({
          flags: this.getOptionFlags(fullKey, schema),
          type: this.getOptionType(fullKey, schema),
          desc: this.getOptionDescription(schema)
        });
        if (schema._type === "boolean" && !addedNoVersions.has(fullKey)) {
          addedNoVersions.add(fullKey);
          rows.push({
            flags: `     --no-${fullKey}`,
            type: import_picocolors.default.dim(""),
            desc: this.generateNoDescription(fullKey)
          });
        }
      }
    }
    return rows;
  }
  generateNoDescription(key) {
    const words = key.split(/(?=[A-Z])|[._-]/).map((w) => w.toLowerCase());
    return `Explicitly disable ${words.join(" ")}`;
  }
  buildUnionRows(key, schema, addedNoVersions) {
    const rows = [];
    const groups = new Map;
    for (const s of schema._schemas) {
      const type = s._type;
      if (!groups.has(type))
        groups.set(type, []);
      groups.get(type).push(s);
    }
    const objectSchemas = groups.get("object") ?? [];
    const nonObjectGroups = Array.from(groups.entries()).filter(([type]) => type !== "object");
    for (const objSchema of objectSchemas) {
      if (objSchema._isAnyKeys) {
        rows.push({
          flags: `     --${key}.<key>`,
          type: this.getOptionType(key, objSchema),
          desc: this.getOptionDescription(objSchema)
        });
      } else {
        const objShape = objSchema._originalShape || objSchema._shape;
        rows.push(...this.buildOptionRows(objShape, key, addedNoVersions));
      }
    }
    for (const [, groupSchemas] of nonObjectGroups) {
      for (const s of groupSchemas) {
        const desc = this.getOptionDescription(s);
        rows.push({
          flags: this.getOptionFlags(key, s),
          type: this.getOptionType(key, s),
          desc
        });
      }
    }
    const hasBooleanSchema = schema._schemas.some((s) => s._type === "boolean");
    if (hasBooleanSchema && !addedNoVersions.has(key)) {
      addedNoVersions.add(key);
      rows.push({
        flags: `     --no-${key}`,
        type: import_picocolors.default.dim(""),
        desc: this.generateNoDescription(key)
      });
    }
    if (schema._description && rows.length) {
      rows[0].desc = `${schema._description}${rows[0].desc ? ` - ${rows[0].desc}` : ""}`;
    }
    return rows;
  }
  getOptionFlags(key, schema) {
    if (schema._type === "object" && schema._isAnyKeys)
      return `     --${key}.<key>`;
    return schema._alias ? ` -${schema._alias}, --${key}` : `     --${key}`;
  }
  getOptionType(_key, schema) {
    if (schema._type === "boolean")
      return import_picocolors.default.dim("");
    let valueType = "val";
    if (schema._type === "string" && schema._choices?.length) {
      const choices = schema._choices;
      valueType = choices.length <= 5 ? choices.join("|") : `${choices.slice(0, 4).join("|")}|...`;
    } else if (schema._type === "number") {
      valueType = "n";
    } else if (schema._type === "array") {
      valueType = "val,...";
    } else if (schema._type === "object" && schema._valueSchema) {
      return this.getOptionType(_key, schema._valueSchema);
    }
    return `  ${import_picocolors.default.dim(`<${valueType}>`)}  `;
  }
  getOptionDescription(schema) {
    const parts = [];
    if (schema._description)
      parts.push(schema._description);
    if (schema._example)
      parts.push(import_picocolors.default.dim(`Example: ${schema._example}`));
    const constraints = this.getConstraints(schema);
    if (constraints)
      parts.push(import_picocolors.default.dim(`(${constraints})`));
    return parts.join(" ");
  }
  getConstraints(schema) {
    const constraints = [];
    if (schema._defaultValue !== undefined) {
      if (schema._defaultMessage) {
        constraints.push(schema._defaultMessage);
      } else {
        const value = schema._type === "boolean" ? schema._defaultValue : JSON.stringify(schema._defaultValue);
        constraints.push(`default: ${value}`);
      }
    }
    if (schema._type === "string") {
      const s = schema;
      if (s._minLength !== undefined)
        constraints.push(`min: ${s._minLength}`);
      if (s._maxLength !== undefined)
        constraints.push(`max: ${s._maxLength}`);
      if (s._regex)
        constraints.push(s._regex.message || `pattern: ${s._regex.pattern}`);
    } else if (schema._type === "number") {
      const n = schema;
      if (n._min !== undefined)
        constraints.push(`min: ${n._min}`);
      if (n._max !== undefined)
        constraints.push(`max: ${n._max}`);
      if (n._isInt)
        constraints.push("integer");
      if (n._isPositive)
        constraints.push("positive");
      if (n._isNegative)
        constraints.push("negative");
    } else if (schema._type === "array") {
      const a = schema;
      if (a._minLength !== undefined)
        constraints.push(`min: ${a._minLength}`);
      if (a._maxLength !== undefined)
        constraints.push(`max: ${a._maxLength}`);
    }
    return constraints.length ? joinWithAnd(constraints) : "";
  }
  buildCommandUsage(command) {
    const parts = [this.cli._name || "cli", command.name];
    if (command.positionals) {
      parts.push(...command.positionals.map((p) => ("_isVariadic" in p) && p._isVariadic ? import_picocolors.default.dim(`[...${p._name}]`) : import_picocolors.default.dim(`<${p._name}>`)));
    }
    if (Object.keys(command.options).length)
      parts.push(import_picocolors.default.cyan("[...flags]"));
    return parts.join(" ");
  }
  printExample(example) {
    const lines = example.split(`
`);
    if (lines.length > 1) {
      console.log(`  ${lines[0]}`);
      console.log(`  ${lines.slice(1).join(`
  `)}`);
    } else {
      console.log(`  ${example}`);
    }
    console.log();
  }
}

class ArgumentParser {
  flagUsage = new Map;
  flagValues = new Map;
  parse(args, options, parseOptions) {
    const parsed = {};
    const rawOptions = {};
    const positionalArgs = [];
    const doubleDashIndex = args.indexOf("--");
    let rawArgs = [];
    const camelCaseOptions = {};
    const keyMapping = new Map;
    for (const [key, schema] of Object.entries(options)) {
      const camelKey = hyphenToCamelCase(key);
      camelCaseOptions[camelKey] = schema;
      keyMapping.set(key, camelKey);
    }
    this.flagUsage.clear();
    this.flagValues.clear();
    if (doubleDashIndex !== -1) {
      rawArgs = args.slice(doubleDashIndex + 1);
      args = args.slice(0, doubleDashIndex);
    }
    const flagOccurrences = this.collectFlagOccurrences(args, options, camelCaseOptions, keyMapping);
    this.detectAndReportConflicts(flagOccurrences, camelCaseOptions);
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      if (arg.startsWith("--")) {
        i += this.parseFlag(arg, args, i, options, camelCaseOptions, rawOptions, keyMapping);
      } else if (arg.startsWith("-") && !this.looksLikeNegativeNumber(arg)) {
        i += this.parseAlias(arg, args, i, camelCaseOptions, rawOptions);
      } else {
        positionalArgs.push(arg);
      }
    }
    positionalArgs.push(...rawArgs);
    for (const [key, schema] of Object.entries(camelCaseOptions)) {
      const originalKey = Array.from(keyMapping.entries()).find(([_, camelKey]) => camelKey === key)?.[0] || key;
      const value = rawOptions[key] !== undefined ? this.parseOptionWithSchema(originalKey, schema, rawOptions[key], camelCaseOptions) : parseOptions?.ignoreOptionDefaultValue ? undefined : schema.parse(undefined, `--${originalKey}`);
      if (value !== undefined) {
        parsed[key] = value;
      }
    }
    return { parsed, positionalArgs, rawArgs };
  }
  collectFlagOccurrences(args, options, camelCaseOptions, keyMapping) {
    const occurrences = new Map;
    for (const arg of args) {
      if (arg.startsWith("--") && !arg.startsWith("--no-")) {
        const [keyPath] = arg.slice(2).split("=");
        const mainKey = this.parseDotPath(keyPath)[0];
        const camelKey = hyphenToCamelCase(mainKey);
        if (options[mainKey] || camelCaseOptions[camelKey]) {
          const normalizedKey = keyMapping.get(mainKey) || camelKey;
          if (!occurrences.has(normalizedKey))
            occurrences.set(normalizedKey, []);
          occurrences.get(normalizedKey).push(arg);
        }
      }
    }
    return occurrences;
  }
  detectAndReportConflicts(occurrences, options) {
    for (const [key, flags] of occurrences.entries()) {
      if (flags.length > 1) {
        const schema = options[key];
        if (schema._type === "union") {
          const hasSimple = flags.some((f) => !f.includes(".") || f.split("=")[0] === `--${key}`);
          const hasObject = flags.some((f) => f.includes(".") && !f.split("=")[0].endsWith(key));
          if (hasSimple && hasObject) {
            const simpleFlags = flags.filter((f) => !f.includes(".") || f.split("=")[0] === `--${key}`);
            const objectFlags = flags.filter((f) => f.includes(".") && !f.split("=")[0].endsWith(key));
            throw new CLIError(`Cannot mix different forms of --${key}

  ${import_picocolors.default.dim("You used both:")}
    ${import_picocolors.default.red("Simple:")} ${simpleFlags.join(", ")}
    ${import_picocolors.default.red("Object:")} ${objectFlags.join(", ")}

  ${import_picocolors.default.dim("Choose one approach:")}
    ${import_picocolors.default.green(`--${key}`)} ${import_picocolors.default.dim("for simple values")}
    ${import_picocolors.default.green(`--${key}.property`)} ${import_picocolors.default.dim("for object properties")}`);
          }
        }
      }
    }
  }
  looksLikeNegativeNumber(arg) {
    return arg.startsWith("-") && /^\d/.test(arg.slice(1));
  }
  parseDotPath(path) {
    const keys = [];
    let current = "";
    let inQuotes = null;
    let escaped = false;
    for (let i = 0;i < path.length; i++) {
      const char = path[i];
      if (escaped) {
        current += char;
        escaped = false;
        continue;
      }
      if (char === "\\") {
        escaped = true;
        continue;
      }
      if (!inQuotes && (char === '"' || char === "'")) {
        inQuotes = char;
        continue;
      }
      if (char === inQuotes) {
        inQuotes = null;
        continue;
      }
      if (char === "." && !inQuotes) {
        if (current) {
          keys.push(current);
          current = "";
        }
        continue;
      }
      current += char;
    }
    if (current) {
      keys.push(current);
    }
    return keys;
  }
  parseValue(value) {
    if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
      return value.slice(1, -1);
    }
    return value;
  }
  parseOptionWithSchema(key, schema, rawValue, _allOptions) {
    if (schema._type === "union") {
      const unionSchema = schema;
      if (typeof rawValue === "object" && !Array.isArray(rawValue)) {
        if ("_unionValue" in rawValue) {
          throw new CLIError(`Cannot mix different value types for --${key}

${ErrorFormatter.showDiff(`--${key} ${ErrorFormatter.formatValue(rawValue._unionValue)} and --${key}.property`, `--${key} value ${import_picocolors.default.dim("or")} --${key}.property value`)}`);
        }
        const objectSchemas = unionSchema._schemas.filter((s) => s._type === "object");
        for (const objSchema of objectSchemas) {
          try {
            return this.validateObjectInUnion(objSchema, rawValue, `--${key}`);
          } catch {}
        }
      }
      const booleanValue = this.parseBooleanValue(rawValue);
      if (booleanValue !== undefined) {
        const boolSchema = unionSchema._schemas.find((s) => s._type === "boolean");
        if (boolSchema) {
          try {
            return boolSchema.parse(booleanValue, `--${key}`);
          } catch {}
        }
      }
      return schema.parse(rawValue, `--${key}`);
    }
    if (schema._type === "object" && typeof rawValue === "object" && !Array.isArray(rawValue)) {
      return this.validateObjectInUnion(schema, rawValue, `--${key}`);
    }
    if (schema._type === "boolean") {
      return schema.parse(this.parseBooleanValue(rawValue) ?? rawValue, `--${key}`);
    }
    return schema.parse(rawValue, `--${key}`);
  }
  parseBooleanValue(value) {
    if (value === true || value === "true" || value === "1")
      return true;
    if (value === false || value === "false" || value === "0")
      return false;
    return;
  }
  validateObjectInUnion(schema, rawValue, path) {
    if (schema._isAnyKeys && schema._valueSchema) {
      const result = {};
      for (const [k, v] of Object.entries(rawValue)) {
        result[k] = schema._valueSchema.parse(v, `${path}.${k}`);
      }
      return result;
    }
    if (schema._shape) {
      const result = {};
      const allOptions = [];
      for (const [k, v] of Object.entries(rawValue)) {
        const camelKey = hyphenToCamelCase(k);
        if (!schema._shape[camelKey]) {
          const validKeys = Object.keys(schema._shape);
          const originalValidKeys = validKeys.map((vk) => schema instanceof ObjectSchemaImpl ? schema.getOriginalKey(vk) : vk);
          for (let i = 0;i < originalValidKeys.length; i++) {
            const vk = originalValidKeys[i];
            allOptions.push(`--${path.slice(2)}.${vk}`);
          }
          const suggestion = this.findSimilarKey(k, originalValidKeys);
          throw new CLIError(`${path}.${k} is not recognized

  ${import_picocolors.default.dim("Available properties:")}
${originalValidKeys.map((vk) => `    ${import_picocolors.default.green(`--${path.slice(2)}.${vk}`)}`).join(`
`)}${suggestion ? `

  ${import_picocolors.default.dim("Did you mean")} ${import_picocolors.default.green(`--${path.slice(2)}.${suggestion}`)}${import_picocolors.default.dim("?")}` : ""}`);
        }
        result[camelKey] = schema._shape[camelKey].parse(v, `${path}.${k}`);
      }
      for (const [k, fieldSchema] of Object.entries(schema._shape)) {
        if (!(k in result)) {
          const originalKey = schema instanceof ObjectSchemaImpl ? schema.getOriginalKey(k) : k;
          result[k] = fieldSchema.parse(undefined, `${path}.${originalKey}`);
        }
      }
      return result;
    }
    return rawValue;
  }
  findSimilarKey(key, validKeys) {
    const lowered = key.toLowerCase();
    return validKeys.find((vk) => vk.toLowerCase() === lowered || vk.toLowerCase().includes(lowered) || lowered.includes(vk.toLowerCase()));
  }
  parseFlag(arg, args, index, options, camelCaseOptions, rawOptions, keyMapping) {
    if (arg.startsWith("--no-")) {
      const keyPath2 = arg.slice(5).split("=")[0];
      const keys2 = this.parseDotPath(keyPath2);
      const mainKey2 = keys2[0];
      const camelMainKey2 = hyphenToCamelCase(mainKey2);
      const mainSchema = options[mainKey2] || camelCaseOptions[camelMainKey2];
      if (!mainSchema) {
        const allKeys = [
          ...Object.keys(options),
          ...Object.keys(camelCaseOptions)
        ];
        const suggestion = this.findSimilarKey(mainKey2, allKeys);
        const availableOptions = [];
        for (const [k, s] of Object.entries(options)) {
          availableOptions.push(`--${k}`);
          if (this.isBooleanSchema(s))
            availableOptions.push(`--no-${k}`);
        }
        throw new CLIError(`${arg} is not recognized

  ${import_picocolors.default.dim("Available options:")}
${availableOptions.map((o) => `    ${import_picocolors.default.green(o)}`).join(`
`)}${suggestion ? `

  ${import_picocolors.default.dim("Did you mean")} ${import_picocolors.default.green(`--no-${suggestion}`)}${import_picocolors.default.dim("?")}` : ""}`);
      }
      if (keys2.length > 1) {
        const nestedKeys = keys2.slice(1);
        const nestedSchema = this.getNestedSchema(mainSchema, nestedKeys);
        if (nestedSchema && this.isBooleanSchema(nestedSchema)) {
          const camelKeys2 = [
            camelMainKey2,
            ...keys2.slice(1).map((k) => hyphenToCamelCase(k))
          ];
          this.setNestedValue(rawOptions, camelKeys2, false, camelCaseOptions);
          return 0;
        }
      } else {
        if (this.isBooleanSchema(mainSchema)) {
          this.setNestedValue(rawOptions, [camelMainKey2], false, camelCaseOptions);
          return 0;
        }
      }
      throw new CLIError(`${arg} cannot be negated

  ${import_picocolors.default.dim("The --no- prefix only works with boolean flags")}`);
    }
    const [keyPath, ...valueParts] = arg.slice(2).split("=");
    const hasExplicitValue = valueParts.length > 0;
    const explicitValue = hasExplicitValue ? this.parseValue(valueParts.join("=")) : undefined;
    const keys = this.parseDotPath(keyPath);
    const mainKey = keys[0];
    const camelMainKey = hyphenToCamelCase(mainKey);
    const schema = options[mainKey] || camelCaseOptions[camelMainKey];
    if (!schema) {
      const allKeys = [
        ...Object.keys(options),
        ...Object.keys(camelCaseOptions)
      ];
      const suggestion = this.findSimilarKey(mainKey, allKeys);
      const availableOptions = [];
      for (const [k, s] of Object.entries(options)) {
        availableOptions.push(`--${k}`);
        if (this.isBooleanSchema(s))
          availableOptions.push(`--no-${k}`);
      }
      throw new CLIError(`--${mainKey} is not recognized

  ${import_picocolors.default.dim("Available options:")}
${availableOptions.map((o) => `    ${import_picocolors.default.green(o)}`).join(`
`)}${suggestion ? `

  ${import_picocolors.default.dim("Did you mean")} ${import_picocolors.default.green(`--${suggestion}`)}${import_picocolors.default.dim("?")}` : ""}`);
    }
    const normalizedMainKey = keyMapping.get(mainKey) || camelMainKey;
    const isSimple = keys.length === 1;
    const currentUsage = this.flagUsage.get(normalizedMainKey);
    const newUsage = isSimple ? "simple" : "object";
    if (currentUsage && currentUsage !== newUsage) {
      this.flagUsage.set(normalizedMainKey, "both");
      if (schema._type === "union") {
        throw new CLIError(`Cannot mix forms for --${mainKey}

  ${import_picocolors.default.dim("Previously used:")} ${currentUsage === "simple" ? import_picocolors.default.yellow(`--${mainKey}`) : import_picocolors.default.yellow(`--${mainKey}.property`)}
  ${import_picocolors.default.dim("Now trying:")} ${isSimple ? import_picocolors.default.red(`--${mainKey}`) : import_picocolors.default.red(`--${keyPath}`)}

  ${import_picocolors.default.dim("Choose one approach consistently:")}
    ${import_picocolors.default.green(`--${mainKey} value`)} ${import_picocolors.default.dim("for simple form")}
    ${import_picocolors.default.green(`--${mainKey}.property value`)} ${import_picocolors.default.dim("for object form")}`);
      }
    } else {
      this.flagUsage.set(normalizedMainKey, newUsage);
    }
    const camelKeys = this.shouldPreserveKeys(schema) ? [camelMainKey, ...keys.slice(1)] : [camelMainKey, ...keys.slice(1).map((k) => hyphenToCamelCase(k))];
    const expectsValue = this.schemaExpectsValue(schema, camelKeys.slice(1), keys.slice(1));
    let consumed = 0;
    if (expectsValue === "required" || expectsValue === "union") {
      let value;
      if (hasExplicitValue) {
        value = explicitValue;
      } else if (index + 1 < args.length && (!args[index + 1].startsWith("-") || this.looksLikeNegativeNumber(args[index + 1]))) {
        value = this.parseValue(args[index + 1]);
        consumed = 1;
      } else if (expectsValue === "union") {
        value = true;
      } else {
        const example = ErrorFormatter.formatCorrectUsage(keys.join("."), undefined, this.getSchemaAtPath(schema, camelKeys.slice(1)));
        throw new CLIError(`--${keys.join(".")} needs a value

  ${import_picocolors.default.dim("Usage:")} ${example}`);
      }
      this.setNestedValue(rawOptions, camelKeys, value, camelCaseOptions);
      this.flagValues.set(normalizedMainKey, value);
    } else if (expectsValue === "boolean") {
      let value;
      if (hasExplicitValue) {
        value = explicitValue;
      } else if (index + 1 < args.length && !args[index + 1].startsWith("-") && this.isBooleanLiteral(args[index + 1])) {
        value = args[index + 1];
        consumed = 1;
      } else {
        value = true;
      }
      this.setNestedValue(rawOptions, camelKeys, value, camelCaseOptions);
      this.flagValues.set(normalizedMainKey, value);
    }
    return consumed;
  }
  getSchemaAtPath(schema, nestedKeys) {
    let current = schema;
    for (const key of nestedKeys) {
      if (current._type === "object") {
        const objSchema = current;
        if (objSchema._isAnyKeys)
          return objSchema._valueSchema;
        if (objSchema._shape?.[key])
          current = objSchema._shape[key];
      } else if (current._type === "union") {
        const unionSchema = current;
        const objSchema = unionSchema._schemas.find((s) => s._type === "object");
        if (objSchema) {
          const obj = objSchema;
          if (obj._isAnyKeys)
            return obj._valueSchema;
          if (obj._shape?.[key])
            current = obj._shape[key];
        }
      }
    }
    return current;
  }
  isBooleanSchema(schema) {
    if (schema._type === "boolean")
      return true;
    if (schema._type === "union") {
      const unionSchema = schema;
      return unionSchema._schemas.some((s) => s._type === "boolean");
    }
    return false;
  }
  getNestedSchema(schema, nestedKeys) {
    if (!schema || !nestedKeys.length)
      return schema;
    let current = schema;
    for (const key of nestedKeys) {
      if (current._type === "object") {
        const objSchema = current;
        if (objSchema._shape) {
          const camelKey = hyphenToCamelCase(key);
          if (objSchema._shape[camelKey]) {
            current = objSchema._shape[camelKey];
          } else {
            return;
          }
        } else {
          return;
        }
      } else if (current._type === "union") {
        const unionSchema = current;
        const objSchema = unionSchema._schemas.find((s) => {
          if (s._type === "object") {
            const obj = s;
            const camelKey = hyphenToCamelCase(key);
            return obj._shape?.[camelKey] !== undefined;
          }
          return false;
        });
        if (objSchema) {
          const camelKey = hyphenToCamelCase(key);
          current = objSchema._shape[camelKey];
        } else {
          return;
        }
      } else {
        return;
      }
    }
    return current;
  }
  isBooleanLiteral(value) {
    return ["true", "false", "0", "1"].includes(value.toLowerCase());
  }
  shouldPreserveKeys(schema) {
    if (schema._type === "object") {
      return schema._isAnyKeys || false;
    }
    if (schema._type === "union") {
      const unionSchema = schema;
      return unionSchema._schemas.some((s) => s._type === "object" && s._isAnyKeys);
    }
    return false;
  }
  schemaExpectsValue(schema, nestedKeys, originalKeys) {
    let current = schema;
    for (let i = 0;i < nestedKeys.length; i++) {
      const key = nestedKeys[i];
      const originalKey = originalKeys?.[i] ?? key;
      if (current._type === "object") {
        const objSchema = current;
        if (objSchema._isAnyKeys) {
          current = objSchema._valueSchema;
          break;
        }
        if (objSchema._shape) {
          const camelKey = hyphenToCamelCase(originalKey);
          if (objSchema._shape[camelKey]) {
            current = objSchema._shape[camelKey];
          } else {
            const validKeys = Object.keys(objSchema._shape || {});
            const originalValidKeys = validKeys.map((k) => objSchema instanceof ObjectSchemaImpl ? objSchema.getOriginalKey(k) : k);
            const suggestion = this.findSimilarKey(originalKey, originalValidKeys);
            throw new CLIError(`Property '${originalKey}' is not recognized

  ${import_picocolors.default.dim("Available properties:")}
${originalValidKeys.map((k) => `    ${import_picocolors.default.cyan(k)}`).join(`
`)}${suggestion ? `

  ${import_picocolors.default.dim("Did you mean")} ${import_picocolors.default.green(suggestion)}${import_picocolors.default.dim("?")}` : ""}`);
          }
        }
      } else if (current._type === "union") {
        const unionSchema = current;
        const objSchema = unionSchema._schemas.find((s) => s._type === "object");
        if (objSchema) {
          const obj = objSchema;
          if (obj._isAnyKeys) {
            current = obj._valueSchema;
            break;
          }
          if (obj._shape) {
            const camelKey = hyphenToCamelCase(originalKey);
            if (obj._shape[camelKey])
              current = obj._shape[camelKey];
          }
        }
      }
    }
    if (current._type === "boolean")
      return "boolean";
    if (current._type === "union") {
      const unionSchema = current;
      const hasBoolean = unionSchema._schemas.some((s) => s._type === "boolean");
      const hasOther = unionSchema._schemas.some((s) => s._type !== "boolean");
      if (hasBoolean && !hasOther)
        return "boolean";
      if (!hasBoolean && hasOther)
        return "required";
      return "union";
    }
    return "required";
  }
  parseAlias(arg, args, index, options, rawOptions) {
    const alias = arg.slice(1);
    const [optionName, schema] = Object.entries(options).find(([_, s]) => s._alias === alias) || [];
    if (!optionName) {
      const allAliases = Object.entries(options).filter(([_, s]) => s._alias).map(([k, s]) => ({ alias: s._alias, flag: k }));
      throw new CLIError(`-${alias} is not recognized

${allAliases.length ? `  ${import_picocolors.default.dim("Available aliases:")}
${allAliases.map(({ alias: a, flag }) => `    ${import_picocolors.default.green(`-${a}`)} ${import_picocolors.default.dim("for")} ${import_picocolors.default.cyan(`--${flag}`)}`).join(`
`)}` : `  ${import_picocolors.default.dim("No aliases are defined for this command")}`}`);
    }
    const expectsValue = this.schemaExpectsValue(schema, []);
    if (expectsValue === "boolean") {
      if (index + 1 < args.length && !args[index + 1].startsWith("-") && this.isBooleanLiteral(args[index + 1])) {
        rawOptions[optionName] = args[index + 1];
        return 1;
      }
      rawOptions[optionName] = true;
      return 0;
    }
    if (expectsValue === "required") {
      if (index + 1 < args.length && !args[index + 1].startsWith("-")) {
        rawOptions[optionName] = this.parseValue(args[index + 1]);
        return 1;
      }
      const example = ErrorFormatter.formatCorrectUsage(optionName, undefined, schema);
      throw new CLIError(`-${alias} needs a value

  ${import_picocolors.default.dim("Usage:")} ${example.replace(`--${optionName}`, `-${alias}`)}`);
    }
    if (index + 1 < args.length && !args[index + 1].startsWith("-")) {
      rawOptions[optionName] = this.parseValue(args[index + 1]);
      return 1;
    }
    rawOptions[optionName] = true;
    return 0;
  }
  setNestedValue(obj, keyOrKeys, value, options) {
    const keys = typeof keyOrKeys === "string" ? this.parseDotPath(keyOrKeys) : keyOrKeys;
    let current = obj;
    let schemaPath = options;
    if (keys.length > 1) {
      const mainKey = keys[0];
      const existingValue = obj[mainKey];
      if (existingValue !== undefined && typeof existingValue !== "object") {
        const schema = options[mainKey];
        if (schema._type === "union") {
          throw new CLIError(`Cannot mix value types for --${mainKey}

  ${import_picocolors.default.dim("Previously set:")} --${mainKey} ${ErrorFormatter.formatValue(existingValue)}
  ${import_picocolors.default.dim("Now trying:")} --${keys.join(".")} ${ErrorFormatter.formatValue(value)}

  ${import_picocolors.default.dim("Use one approach consistently:")}
    ${import_picocolors.default.green(`--${mainKey} value`)} ${import_picocolors.default.dim("for simple values")}
    ${import_picocolors.default.green(`--${mainKey}.property value`)} ${import_picocolors.default.dim("for object properties")}`);
        }
        throw new CLIError(`Cannot set property on non-object value

  ${import_picocolors.default.dim("Flag:")} --${mainKey}
  ${import_picocolors.default.dim("Current value:")} ${ErrorFormatter.formatValue(existingValue)}
  ${import_picocolors.default.dim("Attempted:")} --${keys.join(".")} ${ErrorFormatter.formatValue(value)}`);
      }
    }
    for (let i = 0;i < keys.length - 1; i++) {
      const k = keys[i];
      if (!current[k]) {
        current[k] = {};
      } else if (typeof current[k] !== "object" || Array.isArray(current[k])) {
        const partialKey = keys.slice(0, i + 1).join(".");
        throw new CLIError(`Cannot set nested property

  ${import_picocolors.default.dim("Path:")} --${keys.join(".")}
  ${import_picocolors.default.dim("Conflict at:")} --${partialKey}
  ${import_picocolors.default.dim("Current type:")} ${Array.isArray(current[k]) ? "array" : typeof current[k]}`);
      }
      if (i === 0 && current[k]._unionValue !== undefined) {
        throw new CLIError(`Cannot switch to object form

  ${import_picocolors.default.dim("Previously:")} --${k} ${ErrorFormatter.formatValue(current[k]._unionValue)}
  ${import_picocolors.default.dim("Now trying:")} --${keys.join(".")} ${ErrorFormatter.formatValue(value)}

  ${import_picocolors.default.dim("Use consistent form throughout")}`);
      }
      current = current[k];
      if (schemaPath[k]) {
        const schema = schemaPath[k];
        if (schema._type === "object") {
          const objSchema = schema;
          if (!objSchema._isAnyKeys && objSchema._shape) {
            schemaPath = objSchema._shape;
          }
        } else if (schema._type === "union") {
          const unionSchema = schema;
          const objSchema = unionSchema._schemas.find((s) => s._type === "object" && !s._isAnyKeys);
          if (objSchema) {
            schemaPath = objSchema._shape;
          }
        }
      }
    }
    const lastKey = keys[keys.length - 1];
    if (current[lastKey] !== undefined && !Array.isArray(current[lastKey])) {
      current[lastKey] = [current[lastKey], value];
    } else if (Array.isArray(current[lastKey])) {
      current[lastKey].push(value);
    } else {
      current[lastKey] = value;
    }
  }
}

class CLIImpl {
  _name;
  _version;
  _description;
  _usage;
  _examples = [];
  _options = {};
  _positionals = [];
  _commands = [];
  _parseOptions;
  formatter = new HelpFormatter(this);
  parser = new ArgumentParser;
  name(name) {
    this._name = name;
    return this;
  }
  version(version) {
    this._version = version;
    return this;
  }
  description(description) {
    this._description = description;
    return this;
  }
  usage(usage) {
    this._usage = usage;
    return this;
  }
  example(example) {
    this._examples.push(...Array.isArray(example) ? example : [example]);
    return this;
  }
  option(name, schema) {
    this._options[name] = schema;
    return this;
  }
  positional(name, schema) {
    if (this._positionals.some((p) => ("_isVariadic" in p) && p._isVariadic)) {
      throw new CLIError("Cannot add positional after variadic positional");
    }
    this._positionals.push(new PositionalSchemaImpl(name, schema));
    return this;
  }
  rest(name, schema) {
    if (this._positionals.some((p) => ("_isVariadic" in p) && p._isVariadic)) {
      throw new CLIError("Cannot have multiple variadic positionals");
    }
    this._positionals.push(new VariadicPositionalSchemaImpl(name, schema));
    return this;
  }
  command(name, options) {
    const builder = new CommandBuilderImpl(name, options || {});
    return new Proxy(builder, {
      get: (target, prop) => {
        if (prop === "action") {
          return (fn) => {
            const cmd = target.action(fn);
            this._commands.push(cmd);
            return cmd;
          };
        }
        return target[prop];
      }
    });
  }
  with(options) {
    this._parseOptions = { ...this._parseOptions, ...options };
    return this;
  }
  parse(argv = process.argv.slice(2)) {
    try {
      const result = this.handleArguments([...argv]);
      if (result === "handled")
        return;
      return result;
    } catch (error) {
      this.formatter.showError(error);
      processExit(1, error);
    }
  }
  handleArguments(args) {
    if (this.handleVersion(args))
      return "handled";
    if (this.handleHelp(args))
      return "handled";
    const { command, remainingArgs } = this.extractCommand(args);
    if (command) {
      return this.executeCommand(command, remainingArgs);
    }
    return this.parseMainCommand(args);
  }
  handleVersion(args) {
    if (!this._version)
      return false;
    if (args.includes("--version") || args.includes("-v")) {
      console.log(this._version);
      processExit(0);
    }
    return false;
  }
  handleHelp(args) {
    const helpIndex = args.findIndex((arg) => arg === "--help" || arg === "-h");
    if (helpIndex === -1)
      return false;
    const commandBeforeHelp = helpIndex > 0 ? args[helpIndex - 1] : null;
    const command = commandBeforeHelp && this._commands.find((c) => c.name === commandBeforeHelp);
    if (command) {
      this.formatter.showCommandHelp(command);
    } else {
      this.formatter.showHelp();
    }
    processExit(0);
    return true;
  }
  extractCommand(args) {
    if (!args.length || args[0].startsWith("-"))
      return { remainingArgs: args };
    const commandName = args[0];
    const command = this._commands.find((c) => c.name === commandName);
    if (command) {
      return { command, remainingArgs: args.slice(1) };
    }
    if (this._commands.length) {
      const similar = this._commands.find((c) => c.name.toLowerCase() === commandName.toLowerCase() || c.name.toLowerCase().includes(commandName.toLowerCase()) || commandName.toLowerCase().includes(c.name.toLowerCase()))?.name;
      throw new CLIError(`Command '${commandName}' not found

  ${import_picocolors.default.dim("Available commands:")}
${this._commands.map((c) => `    ${import_picocolors.default.green(c.name)}`).join(`
`)}${similar ? `

  ${import_picocolors.default.dim("Did you mean")} ${import_picocolors.default.green(similar)}${import_picocolors.default.dim("?")}` : ""}`);
    }
    return { remainingArgs: args };
  }
  executeCommand(command, args) {
    const { parsed, positionalArgs } = this.parser.parse(args, command.options, this._parseOptions);
    const { positionals, rest } = this.parsePositionals(positionalArgs, command.positionals || []);
    const result = command.action({
      options: parsed,
      positionals,
      rest
    });
    if (result instanceof Promise) {
      result.catch((err) => {
        this.formatter.showError(err);
        processExit(1, err);
      });
    }
    return "handled";
  }
  parseMainCommand(args) {
    const { parsed, positionalArgs } = this.parser.parse(args, this._options, this._parseOptions);
    const { positionals, rest } = this.parsePositionals(positionalArgs, this._positionals);
    return {
      options: parsed,
      positionals,
      rest
    };
  }
  parsePositionals(args, schemas) {
    const positionals = [];
    let rest = undefined;
    const variadicIndex = schemas.findIndex((s) => ("_isVariadic" in s) && s._isVariadic);
    if (variadicIndex !== -1) {
      for (let i = 0;i < variadicIndex; i++) {
        const schema = schemas[i];
        const value = args[i];
        try {
          positionals.push(schema.parse(value, schema._name));
        } catch (error) {
          const message = error instanceof Error ? error.message.replace(`${schema._name} `, "").replace(`${schema._name}: `, "") : String(error);
          throw new CLIError(`Argument <${schema._name}>: ${message}`);
        }
      }
      const variadicSchema = schemas[variadicIndex];
      const variadicArgs = args.slice(variadicIndex);
      try {
        rest = variadicSchema.parse(variadicArgs, variadicSchema._name);
      } catch (error) {
        const message = error instanceof Error ? error.message.replace(`${variadicSchema._name} `, "").replace(`${variadicSchema._name}: `, "") : String(error);
        throw new CLIError(`Argument <${variadicSchema._name}>: ${message}`);
      }
    } else {
      for (let i = 0;i < schemas.length; i++) {
        const schema = schemas[i];
        const value = args[i];
        try {
          positionals.push(schema.parse(value, schema._name));
        } catch (error) {
          const message = error instanceof Error ? error.message.replace(`${schema._name} `, "").replace(`${schema._name}: `, "") : String(error);
          throw new CLIError(`Argument <${schema._name}>: ${message}`);
        }
      }
      if (args.length > schemas.length) {
        const extra = args.slice(schemas.length);
        throw new CLIError(`Too many arguments provided

  ${import_picocolors.default.dim("Expected:")} ${schemas.length} argument${schemas.length !== 1 ? "s" : ""}
  ${import_picocolors.default.dim("Received:")} ${args.length} argument${args.length !== 1 ? "s" : ""}

  ${import_picocolors.default.dim("Extra:")} ${extra.map((e) => import_picocolors.default.red(e)).join(", ")}`);
      }
    }
    return {
      positionals: schemas.length === 0 && variadicIndex === -1 ? args : positionals,
      rest
    };
  }
}
var z = {
  string: () => new StringSchemaImpl,
  number: () => new NumberSchemaImpl,
  boolean: () => new BooleanSchemaImpl,
  array: (schema) => new ArraySchemaImpl(schema),
  object: (shapeOrValueSchema) => {
    return new ObjectSchemaImpl(shapeOrValueSchema);
  },
  union: (...schemas) => new UnionSchemaImpl(schemas)
};
function cli() {
  return new CLIImpl;
}
